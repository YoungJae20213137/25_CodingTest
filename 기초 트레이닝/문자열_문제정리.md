# 기초 트레이닝 정리

[Python] 

## 문자열

### Q38(글자 이어 붙여 문자열 만들기) / 문자열 

```Python
def solution(my_string, index_list):
    answer = []
    string_list = list(my_string)
    
    for val in index_list:
        answer.append(string_list[val])
        
    text = ''.join(answer)
    
    return text

if __name__ == "__main__":
    my_string = input().strip()
    index_list = list(map(int, input()))
    
    result = solution(my_string, index_list)
    
    print(result)
```
**주요 개념 및 로직**
1. string을 리스트로 변환 -> list() 사용
2. list를 다시 string으로 변환 -> ''.join() 사용 (공백 없이 이어붙이기)

***

### Q39(9로 나눈 나머지) / 문자열
```Python
def solution(number):
    digit_sum = 0
    for digit in number:
        digit_sum += int(digit)
    answer = digit_sum % 9
    return answer

if __name__ == "__main__":
    number = input()
    result = solution(number)
    
    print(result)
```
**주요 개념 및 로직**
1. number 문자열에서 자릿수 별로 int 변환해서 더하기

***

### Q40(문자열 여러 번 뒤집기) / 문자열
```Python
def solution(my_string, queries):
    answer = ''
    str = list(my_string)
    
    for i, j in queries:
        str[i:j+1] = reversed(str[i:j+1])
    
    answer = ''.join(str)
                
    return answer

if __name__ == "__main__" :
    my_string = input()
    queries = input()
    
    result = solution(my_string, queries)
    
    print(result)
```
**주요 개념 및 로직**
1. 문자열을 리스트로 변환
2. 리스트 슬라이싱(끝 부분 포함 안됨)
3. 다시 스트링 변환

***

### Q41(배열 만들기 5) / 문자열
```Python
def solution(intStrs, k, s, l):
    answer = []
    
    for val in intStrs:
        if int(val[s:s+l]) > k:
            answer.append(int(val[s:s+l]))
    return answer

if __name__ == "__main__":
    intStrs = list(map(int, input().strip()))
    k, s, l = input()
    
    result = solution(intStrs, k, s, l)
    
    print(result)
```
**주요 개념 및 로직**
1. 처음 string으로 받은 배열 int로 매핑, 공백 제거
2. 원소값 슬라이싱할 때, s: 시작 위치, s+l: 끝 위치 지정
3. k(int) 값과 비교를 위해 int 변환

***

### Q42(부분 문자열 이어 붙여 문자열 만들기) / 문자열
```Python
def solution(my_strings, parts):
    answer = ''
    answer = list(answer)
    k = 0
    
    for string in my_strings:
        i, j = parts[k]
        answer.append(string[i:j+1])
        k = k + 1

    result = ''.join(answer)
        
    return result

if __name__ == "__main__":
    my_strings = list(input())
    parts = list(input())
    
    result = solution(my_strings, parts)
    
    print(result)
```
**주요 개념 및 로직**
 1. my_strings와 parts 리스트 변환
 2. string 원소들을 parts에 있는 0번째 원소(i: 시작, j: 끝)부터 my_strings에 있는 원소 개수 까지 슬라이싱
 3. 초기 k 값은 증가
 4. 마지막에 answer 리스트를 string으로 변환해서 결과 반환

***

### Q43(문자열의 뒤의 n글자) / 문자열
```Python
def solution(my_string, n):
    answer = ''
    answer = my_string[-n:]
    return answer

if __name__ == "__main__":
    my_string = list(input())
    n = input()
    
    result = solution(my_string, n)
    
    print(result)
```
**주요 개념 및 로직**
1. [-n:]은 뒤에서부터 n번째부터 끝까지 슬라이싱

***

### Q44(접미사 배열) / 문자열
```Python
def solution(my_string):
    answer = []
    
    for i in range(len(my_string)):
        char = my_string[-i:]
        answer.append(char)
        
    answer = sorted(answer)
    return answer

if __name__ == "__main__":
    my_string = list(input())
    
    result = solution(my_string)
    
    print(result)
```
**주요 개념 및 로직**
1. i 값에는 입력된 my_string의 길이가 하나씩 담기게 됨
2. char에는 접미사가 저장, answer 배열에 하나씩 담기게 됨
3. sorted()로 사전 정렬 가능

***

### Q45(접미사인지 확인하기) / 문자열
```Python
def solution(my_string, is_suffix):
    answer = 0
    comp = []
    
    # 접미사 리스트 만들기
    for i in range(len(my_string)):
        comp.append(my_string[-i:])
        
    # is_suffix와 비교
    if(is_suffix in comp):
        answer = 1
    else:
        answer = 0
    
    return answer

if __name__ == "__main__":
    my_string = list(input())
    is_suffix = input()
    
    result = solution(my_string, is_suffix)
    
    print(result)
```
**주요 개념 및 로직**
1. 44번 문제처럼 접미사 배열 만들기
2. in을 사용해서 is_suffix가 리스트에 있는지 검사

***

### Q46(문자열의 앞의 n글자) / 문자열
```Python
def solution(my_string, n):
    answer = '' 
    answer = str(my_string[:n])
    
    return answer

if __name__ == "__main__":
    my_string = list(input())
    n = input()
    
    result = solution(my_string, n)
    
    print(result)
```
**주요 개념 및 로직**
1. [:n]은 처음부터 n자리까지 추출

***

### Q47(접두사인지 확인하기) / 문자열
```Python
def solution(my_string, is_prefix):
    answer = 0
    comp = []
    
    # 접두사 리스트
    for i in range(len(my_string)):
        comp.append(my_string[:i])
        
    # is_prefix와 비교
    if(is_prefix in comp):
        answer = 1
    else:
        answer = 0
    
    return answer

if __name__ == "__main__":
    my_string = list(input())
    is_prefix = input()
    
    result = solution(my_string, is_prefix)
    
    print(result)
```
**주요 개념 및 로직**
1. 45번 문제와 유사
2. 접두사 배열 만들기
3. in을 사용해서 is_suffix가 리스트에 있는지 검사

***

### Q48(문자열 뒤집기) / 문자열
```Python
def solution(my_string, s, e):
    answer = ''
    answer = my_string[:s] + my_string[s:e+1][::-1] + my_string[e+1:]
    
    return answer

if __name__ == "__main__":
    my_string = list(input())
    s, e = input()
    
    result = solution(my_string, s, e)
    
    print(result)
```
**주요 개념 및 로직**
1. 문자열의 일부분을 뒤집고 싶을 때
2. 처음부터 뒤집는 부분의 시작위치까지 슬라이싱
3. 뒤집는 부분의 시작 위치:끝 위치+1까지 슬라이싱 후, -1 step으로 뒤집기
4. 끝 위치+1부터 끝까지 슬라이싱
5. 슬라이싱 한 부분 다 더하기

***

### Q49(세로 읽기) / 문자열
```Python
def solution(my_string, m, c):
    answer = ''
    answer = list(answer)
    
    # 빈 행렬 만들기
    matrix = []
    
    # 열 개수는 m, 행 개수는 문자열 길이 따라 자동 적용
    cols = m
    rows = (len(my_string) + cols - 1) // cols
    
    for i in range(rows):
        row = [] # 각 행마다 빈 리스트 계속 만들어주기
        for j in range(cols):
            idx = i * cols + j # 각 행의 몇번째 열(인덱스)
            if idx < len(my_string):
                row.append(my_string[idx])
            else:
                row.append('')
        matrix.append(row)
        
    # 세로 읽기
    c -= 1
    for r in range(rows):
        answer.append(matrix[r][c])
        
    return ''.join(answer)

if __name__ == "__main__":
    my_string = input()
    m, c = map(int, input().split())
    
    result = solution(my_string, m, c)
    
    print(result)
```
**주요 개념 및 로직**
1. 열 개수는 사용자에게 입력 받지만, 행 개수는 올림 나누기를 통해 획득 (x + y - 1 // y)
2. 행렬 생성(각 행마다 빈 리스트 생성, 각 행에서 열들을 채우기 위해, 문자열의 인덱스를 이용(몇 번째 행의 몇 번째 열 공식: i * cols + j)
3. 얻은 인덱스로 값을 채우기 전, 스트링의 전체 길이와 생성한 행렬에서의 마지막 행의 차이를 비교하여 값을 채울지, 빈 문자열을 채울지 로직을 구현 -> 최종 값 채우기
4. 생성한 행렬에서 행 값(-1 : 0부터 시작함)을 이용해 사용자에게 입력받은 열 값으로 전체 행을 순회하며 문자를 가져와서 answer 리스트에 저장
5. 반환은 string으로

***

### Q50(qr code) / 문자열
```Python
def solution(q, r, code):
    answer = ''
    answer = list(answer)
    
    matrix = []
    
    # 행과 열 값
    cols = q
    rows = (len(code) + cols - 1) // cols
    
    # matrix 생성
    for i in range(rows):
        row = []
        for j in range(cols):
            idx = i * cols + j
            if idx < len(code):
                row.append(code[idx])
            else:
                row.append('')
        matrix.append(row)
    
    # 나머지가 r인(열이 r인) 값들 모으기
    for k in range(rows):
        if matrix[k][r] != '':
            answer.append(matrix[k][r])
        
    return ''.join(answer)

if __name__ == "__main__":
    q, r = map(int, input().split())
    code = list(input())
    
    result = solution(q, r, code)
    
    print(result)
```
**주요 개념 및 로직**
1. 49번 문제와 유사
2. 행, 열 값을 만들고, 주어진 스트링을 기반으로 행렬을 생성
3. 전체 스트링의 길이를 주어진 열값만큼 나누었을 때의 각 행마다 나머지 열의 위치에 있는 값들을 모으기

***
