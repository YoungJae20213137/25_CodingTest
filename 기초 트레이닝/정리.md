# 기초 트레이닝 정리

[Python] 

### Q37(주사위 게임) / 조건문

```Python
def solution(a, b, c, d):
    num_list = [a, b, c, d]
    answer = 0
    # 1번째: 모두 같은지 비교
    all_same = True
    for val in num_list:
        if val != num_list[0]:
            all_same = False
    
    if all_same:
        answer = 1111 * num_list[0]
        
    counts = []
    
    if not all_same:
        values = set(num_list)
        for v in values:
            cnt = num_list.count(v)
            counts.append(cnt)
        
        if len(values) == 2:
            # 2번째: 하나만 다른 값
            if sorted(counts) == [1, 3]:
                for v in values:
                    if num_list.count(v) == 3:
                        p = v
                    else:
                        q = v
                answer = pow(10 * p + q, 2)
                
            # 3번째: 두개씩 같은 값
            elif sorted(counts) == [2, 2]:
                vals = list(values)
                p = vals[0]
                q = vals[1]
            
                answer = abs((p + q) * (p - q))
            
            # 4번째: 두개만 같고, 나머지는 다른 값
        elif len(values) == 3:
            if sorted(counts) == [1, 1, 2]:
                q = None
                r = None
                for v in values:
                    if num_list.count(v) == 1:
                        if q is None:
                            q = v
                        else:
                            r = v
                answer = q * r
                
            # 5번째: 모두 다 다른 값
        else:
            min_val = min(values)
            answer = min_val
        
    return int(answer)

if __name__ == "__main__":
    user_input = input()
    num_list = list(map(int, user_input.split(',')))
    
    result = solution(num_list)
    
    print(result)
```
**주요 개념 및 로직**
1. all_same이라는 플래그 선언 후, 리스트[0] 값과 비교하는 로직
2. values set을 만들고(중복 제거), set 원소별 count 리스트를 만듦
3. count 리스트를 통해 하나만 다른 값을 찾기
4. 마찬가지로, count 리스트를 통해 두 개의 값들 구별하기
5. 두 개는 같고, 나머지 두 개는 서로 다른 값일 때, q와 r에 None 값 할당 후, count가 1인 것 중, 비어있는 q에 먼저 할당
6. 모두 다 다른 값은 최소 값 배정
7. main에서는 list(), map(int, X) 메서드 사용

***

### Q38(글자 이어 붙여 문자열 만들기) / 문자열 

```Python
def solution(my_string, index_list):
    answer = []
    string_list = list(my_string)
    
    for val in index_list:
        answer.append(string_list[val])
        
    text = ''.join(answer)
    
    return text

if __name__ == "__main__":
    my_string = input().strip()
    index_list = list(map(int, input()))
    
    result = solution(my_string, index_list)
    
    print(result)
```
**주요 개념 및 로직**
1. string을 리스트로 변환 -> list() 사용
2. list를 다시 string으로 변환 -> ''.join() 사용 (공백 없이 이어붙이기)

***

### Q39(9로 나눈 나머지) / 문자열
```Python
def solution(number):
    digit_sum = 0
    for digit in number:
        digit_sum += int(digit)
    answer = digit_sum % 9
    return answer

if __name__ == "__main__":
    number = input()
    result = solution(number)
    
    print(result)
```
**주요 개념 및 로직**
1. number 문자열에서 자릿수 별로 int 변환해서 더하기

***

### Q40(문자열 여러 번 뒤집기) / 문자열
```Python
def solution(my_string, queries):
    answer = ''
    str = list(my_string)
    
    for i, j in queries:
        str[i:j+1] = reversed(str[i:j+1])
    
    answer = ''.join(str)
                
    return answer

if __name__ == "__main__" :
    my_string = input()
    queries = input()
    
    result = solution(my_string, queries)
    
    print(result)
```
**주요 개념 및 로직**
1. 문자열을 리스트로 변환
2. 리스트 슬라이싱(끝 부분 포함 안됨)
3. 다시 스트링 변환

***

### Q41(배열 만들기 5) / 문자열
```Python
def solution(intStrs, k, s, l):
    answer = []
    
    for val in intStrs:
        if int(val[s:s+l]) > k:
            answer.append(int(val[s:s+l]))
    return answer

if __name__ == "__main__":
    intStrs = list(map(int, input().strip()))
    k, s, l = input()
    
    result = solution(intStrs, k, s, l)
    
    print(result)
```
**주요 개념 및 로직**
1. 처음 string으로 받은 배열 int로 매핑, 공백 제거
2. 원소값 슬라이싱할 때, s: 시작 위치, s+l: 끝 위치 지정
3. k(int) 값과 비교를 위해 int 변환

***

### Q42(부분 문자열 이어 붙여 문자열 만들기) / 문자열
```Python
def solution(my_strings, parts):
    answer = ''
    answer = list(answer)
    k = 0
    
    for string in my_strings:
        i, j = parts[k]
        answer.append(string[i:j+1])
        k = k + 1

    result = ''.join(answer)
        
    return result

if __name__ == "__main__":
    my_strings = list(input())
    parts = list(input())
    
    result = solution(my_strings, parts)
    
    print(result)
```
**주요 개념 및 로직**
 1. my_strings와 parts 리스트 변환
 2. string 원소들을 parts에 있는 0번째 원소(i: 시작, j: 끝)부터 my_strings에 있는 원소 개수 까지 슬라이싱
 3. 초기 k 값은 증가
 4. 마지막에 answer 리스트를 string으로 변환해서 결과 반환

***

### Q43(문자열의 뒤의 n글자) / 문자열
```Python
def solution(my_string, n):
    answer = ''
    answer = my_string[-n:]
    return answer

if __name__ == "__main__":
    my_string = list(input())
    n = input()
    
    result = solution(my_string, n)
    
    print(result)
```
**주요 개념 및 로직**
1. [-n:]은 뒤에서부터 n번째부터 끝까지 슬라이싱

***

### Q44(접미사 배열) / 문자열
```Python
def solution(my_string):
    answer = []
    
    for i in range(len(my_string)):
        char = my_string[-i:]
        answer.append(char)
        
    answer = sorted(answer)
    return answer

if __name__ == "__main__":
    my_string = list(input())
    
    result = solution(my_string)
    
    print(result)
```
**주요 개념 및 로직**
1. i 값에는 입력된 my_string의 길이가 하나씩 담기게 됨
2. char에는 접미사가 저장, answer 배열에 하나씩 담기게 됨
3. sorted()로 사전 정렬 가능

***

### Q45(접미사인지 확인하기) / 문자열
```Python
def solution(my_string, is_suffix):
    answer = 0
    comp = []
    
    # 접미사 리스트 만들기
    for i in range(len(my_string)):
        comp.append(my_string[-i:])
        
    # is_suffix와 비교
    if(is_suffix in comp):
        answer = 1
    else:
        answer = 0
    
    return answer

if __name__ == "__main__":
    my_string = list(input())
    is_suffix = input()
    
    result = solution(my_string, is_suffix)
    
    print(result)
```
**주요 개념 및 로직**
1. 44번 문제처럼 접미사 배열 만들기
2. in을 사용해서 is_suffix가 리스트에 있는지 검사

***

### Q46(문자열의 앞의 n글자) / 문자열
```Python
def solution(my_string, n):
    answer = '' 
    answer = str(my_string[:n])
    
    return answer

if __name__ == "__main__":
    my_string = list(input())
    n = input()
    
    result = solution(my_string, n)
    
    print(result)
```
**주요 개념 및 로직**
1. [:n]은 처음부터 n자리까지 추출

***

### Q47(접두사인지 확인하기) / 문자열
```Python
def solution(my_string, is_prefix):
    answer = 0
    comp = []
    
    # 접두사 리스트
    for i in range(len(my_string)):
        comp.append(my_string[:i])
        
    # is_prefix와 비교
    if(is_prefix in comp):
        answer = 1
    else:
        answer = 0
    
    return answer

if __name__ == "__main__":
    my_string = list(input())
    is_prefix = input()
    
    result = solution(my_string, is_prefix)
    
    print(result)
```
**주요 개념 및 로직**
1. 45번 문제와 유사
2. 접두사 배열 만들기
3. in을 사용해서 is_suffix가 리스트에 있는지 검사

***

### Q48(문자열 뒤집기) / 문자열
```Python
def solution(my_string, s, e):
    answer = ''
    answer = my_string[:s] + my_string[s:e+1][::-1] + my_string[e+1:]
    
    return answer

if __name__ == "__main__":
    my_string = list(input())
    s, e = input()
    
    result = solution(my_string, s, e)
    
    print(result)
```
**주요 개념 및 로직**
1. 문자열의 일부분을 뒤집고 싶을 때
2. 처음부터 뒤집는 부분의 시작위치까지 슬라이싱
3. 뒤집는 부분의 시작 위치:끝 위치+1까지 슬라이싱 후, -1 step으로 뒤집기
4. 끝 위치+1부터 끝까지 슬라이싱
5. 슬라이싱 한 부분 다 더하기

***

### Q49(세로 읽기) / 문자열
```Python
def solution(my_string, m, c):
    answer = ''
    answer = list(answer)
    
    # 빈 행렬 만들기
    matrix = []
    
    # 열 개수는 m, 행 개수는 문자열 길이 따라 자동 적용
    cols = m
    rows = (len(my_string) + cols - 1) // cols
    
    for i in range(rows):
        row = [] # 각 행마다 빈 리스트 계속 만들어주기
        for j in range(cols):
            idx = i * cols + j # 각 행의 몇번째 열(인덱스)
            if idx < len(my_string):
                row.append(my_string[idx])
            else:
                row.append('')
        matrix.append(row)
        
    # 세로 읽기
    c -= 1
    for r in range(rows):
        answer.append(matrix[r][c])
        
    return ''.join(answer)

if __name__ == "__main__":
    my_string = input()
    m, c = map(int, input().split())
    
    result = solution(my_string, m, c)
    
    print(result)
```
**주요 개념 및 로직**
1. 열 개수는 사용자에게 입력 받지만, 행 개수는 올림 나누기를 통해 획득 (x + y - 1 // y)
2. 행렬 생성(각 행마다 빈 리스트 생성, 각 행에서 열들을 채우기 위해, 문자열의 인덱스를 이용(몇 번째 행의 몇 번째 열 공식: i * cols + j)
3. 얻은 인덱스로 값을 채우기 전, 스트링의 전체 길이와 생성한 행렬에서의 마지막 행의 차이를 비교하여 값을 채울지, 빈 문자열을 채울지 로직을 구현 -> 최종 값 채우기
4. 생성한 행렬에서 행 값(-1 : 0부터 시작함)을 이용해 사용자에게 입력받은 열 값으로 전체 행을 순회하며 문자를 가져와서 answer 리스트에 저장
5. 반환은 string으로

***

### Q50(qr code) / 문자열
```Python
