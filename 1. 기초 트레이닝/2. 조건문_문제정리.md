# 기초 트레이닝 정리

[Python] 

모든 문제 번호는 '최신순' 정렬 되어 있는 문제들의 번호임.

## 조건문

### Q18(홀짝에 따라 다른 값 반환하기) / 조건문
```Python
def solution(n):
    answer = 0
    
    if (n % 2 == 0):
        for i in range(0, n+1, 2):
            answer += pow(i, 2)
    else:
        for i in range(1, n+1, 2):
            answer += i
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. n을 2로 나눈 나머지가 0이면(짝수이면) 0부터 n까지 2개씩(짝수인 것들만 골라내기) for문을 돌리고, i(짝수)를 제곱한 것들을 answer에 더한다.
2. 홀수이면 1부터 n까지 2개씩(홀수인 것들만 골라내기) for문을 돌리고, i(홀수)를 answer에 더한다.

***

### Q19(조건 문자열) / 조건문
```Python
def solution(ineq, eq, n, m):
    answer = 0
    
    if (ineq == '>' and eq == '='):
        answer = (n >= m)
    elif (ineq == '>' and eq == '!'):
        answer = (n > m)
    elif (ineq == '<' and eq == '='):
        answer = (n <= m)
    elif (ineq == '<' and eq == '!'):
        answer = (n < m)
        
    answer = 1 if answer == True else 0
    
    return answer

if __name__ == "__main__":
    ineq, eq = input()
    n, m = int(input())
    
    result = solution(ineq, eq, n, m)
    print(result)
```
**주요 개념 및 로직**
1. ineq와 eq의 조건들을 비교해 bool 값으로 answer에 할당하고, 이후에 answer가 True면 answer에 1, False면 0을 할당한다.

***

### Q20(flag에 따라 다른 값 반환하기) / 조건문
```Python
def solution(a, b, flag):
    answer = (a + b) if flag == True else (a - b)
    return answer

if __name__ == "__main__":
    a, b = int(input())
    flag = bool(input())
    
    result = solution(a, b, flag)
    print(result)
```
**주요 개념 및 로직**
1. flag가 True라면 a + b를, False라면 a - b를 answer에 할당한다.

***

### Q21(코드 처리하기) / 조건문
```Python
def solution(code):
    answer = ''
    mode = 0
    
    for i in range(len(code)):
        if (mode == 0):
            if (code[i] != '1' and i % 2 == 0):
                answer += code[i]
            elif (code[i] == '1'):
                mode = 1
        elif (mode == 1):
            if (code[i] != '1' and i % 2 != 0):
                answer += code[i]
            elif (code[i] == '1'):
                mode = 0
                
    return answer if answer else "EMPTY"

if __name__ == "__main__":
    code = input()
    
    result = solution(code)
    print(result)
```
**주요 개념 및 로직**
1. mode를 처음에 0으로 선언하고, code의 길이만큼 for문을 돌린다:
2. mode가 0일때, 문자가 1이 아니고 해당 문자의 인덱스가 짝수일 때, 그 문자를 answer에 더한다. 만약 문자가 1이라면 모드를 1로 바꾼다.
3. mode가 1일때, 문자가 1이 아니고 해당 문자의 인덱스가 홀수일 때, 그 문자를 answer에 더한다. 만약 문자가 1이라면 모드를 0으로 바꾼다.

***

### Q22(등차수열의 특정한 항만 더하기) / 조건문
```Python
def solution(a, d, included):
    answer = 0
    
    for i in range(len(included)):
        if (included[i] == True):
            answer += a + i * d
            
    return answer

if __name__ == "__main__":
    a, d = int(input())
    included = list(map(bool, input()))
    
    result = solution(a, d, included)
    print(result)
```
**주요 개념 및 로직**
1. included 배열의 길이만큼 for문을 돌린다:
2. boolean 배열인 included의 원소가 True인 원소의 인덱스에 공차 d를 곱하고 첫째항 a를 더하여 등차수열의 해당 항을 answer에 전부 더할 수 있도록 한다.

***

### Q23(주사위 게임 2) / 조건문
```Python
def solution(a, b, c):
    answer = 0
    
    if (a != b and b != c and c != a):
        answer = a + b + c
    elif ((a == b and b != c) or (b == c and c != a) or (a == c and c != b)):
        answer = (a + b + c) * (pow(a, 2) + pow(b, 2) + pow(c, 2))
    elif (a == b and b == c):
        answer = (a + b + c) * (pow(a, 2) + pow(b, 2) + pow(c, 2)) * (pow(a, 3) + pow(b, 3) + pow(c, 3))
        
    return answer

if __name__ == "__main__":
    a, b, c = int(input())
    
    result = solution(a, b, c)
    print(result)
```
**주요 개념 및 로직**
1. 조건을 잘 보고 적절히 분기하여 answer에 적절한 값을 할당한다.
2. 다른 풀이: 중복을 제거하기 위해 set 연산을 쓰는 방법도 있었다.

***

### Q24(원소들의 곱과 합) / 조건문
```Python
def solution(num_list):
    answer = 0
    multi = 1
    
    for num in num_list:
        multi *= num
    
    answer = 1 if (multi < pow(sum(num_list), 2)) else 0
        
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(result)
```
**주요 개념 및 로직**
1. num_list 원소들의 곱들을 담을 multi를 선언하고, for문으로 값을 담는다.
2. if문으로 multi가 num_list 원소들의 합의 제곱보다 작으면 answer에 1을, 아니면 0을 할당한다.

***

### Q25(이어 붙인 수) / 조건문
```Python
def solution(num_list):
    answer = 0
    even_string = ''
    odd_string = ''
    
    for num in num_list:
        if (num % 2 == 0):
            even_string += str(num)
        else:
            odd_string += str(num)
    
    answer = int(even_string) + int(odd_string)
                        
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(result)
```
**주요 개념 및 로직**
1. 짝수 스트링을 담을 변수와 홀수 스트링을 담을 변수를 선언하고,
2. num_list의 원소들을 순회하며 짝수는 짝수 스트링에 str값으로, 홀수는 홀수 스트링에 str값으로 이어 붙인다.
3. 최종 answer에는 두 개의 스트링을 int형으로 바꿔 더한 값을 할당한다.

***

### Q26(마지막 두 원소) / 조건
```Python
def solution(num_list):
    answer = []
    
    if (num_list[-1] > num_list[-2]):
        num_list.append(num_list[-1] - num_list[-2])
    else:
        num_list.append(num_list[-1] * 2)
    
    answer = num_list
    
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(result)
```
**주요 개념 및 로직**
1. list의 마지막 원소(인덱스는 -1)와 마지막 전 원소(인덱스는 -2)를 비교하여 전자가 크면 두 개를 뺀 값을 붙이고, 후자가 크면 마지막 값을 2배하여 붙인다.

***

### Q27(수 조작하기 1) / 조건문
```Python
def solution(n, control):
    answer = 0
    
    for val in control:
        if (val == 'w'):
            n += 1
        elif (val == 's'):
            n -= 1
        elif (val == 'd'):
            n += 10
        elif (val == 'a'):
            n -= 10
    
    answer = n
    
    return answer

if __name__ == "__main__":
    n = int(input())
    control = input()
    
    result = solution(n, control)
    print(result)
```
**주요 개념 및 로직**
1. control에 있는 문자를 하나씩 읽어서 w, s, d, a에 따라 n 값을 적절히 더하고 빼는 과정을 반복하고, 최종 n 값이 answer가 된다.

***

### Q28(수 조작하기 2) / 조건문
```Python
def solution(numLog):
    answer = ''
    
    for i in range(len(numLog)-1):
        if (numLog[i+1] - numLog[i] == 1):
            answer += 'w'
        elif (numLog[i+1] - numLog[i] == -1):
            answer += 's'
        elif (numLog[i+1] - numLog[i] == 10):
            answer += 'd'
        elif (numLog[i+1] - numLog[i] == -10):
            answer += 'a'
            
    return answer

if __name__ == "__main__":
    numLog = list(map(int, input()))
    
    result = solution(numLog)
    print(result)
```
**주요 개념 및 로직**
1. 다음 인덱스와 현재 인덱스의 차이를 계산해서 결과값을 바탕으로 어떤 키가 눌러졌는지 판단하기 위해 for문의 길이는 numLog 배열의 길이를 넘지 않게 하기 위해 -1을 해준다.
2. 다음 인덱스와 현재 인덱스의 차이를 계산해 1이라면 w, -1이라면s, 10이라면 d, -10이라면 a를 answer에 붙인다.

***

### Q36(간단한 논리 연산) / 조건문
```Python
def solution(x1, x2, x3, x4):
    answer = True
    answer = (x1 or x2) and (x3 or x4)
    
    return answer

if __name__ == "__main__":
    x1, x2, x3, x4 = input()
    
    result = solution(x1, x2, x3, x4)
    print(result)
```
**주요 개념 및 로직**
1. ∨ = or 연산, ∧ = and 연산이라는 점을 생각하면 (x1 ∨ x2) ∧ (x3 ∨ x4)를 계산한 최종 boolean 값을 알 수 있다.

***

### Q37(주사위 게임 3) / 조건문
```Python
def solution(a, b, c, d):
    num_list = [a, b, c, d]
    answer = 0
    # 1번째: 모두 같은지 비교
    all_same = True
    for val in num_list:
        if val != num_list[0]:
            all_same = False
    
    if all_same:
        answer = 1111 * num_list[0]
        
    counts = []
    
    if not all_same:
        values = set(num_list)
        for v in values:
            cnt = num_list.count(v)
            counts.append(cnt)
        
        if len(values) == 2:
            # 2번째: 하나만 다른 값
            if sorted(counts) == [1, 3]:
                for v in values:
                    if num_list.count(v) == 3:
                        p = v
                    else:
                        q = v
                answer = pow(10 * p + q, 2)
                
            # 3번째: 두개씩 같은 값
            elif sorted(counts) == [2, 2]:
                vals = list(values)
                p = vals[0]
                q = vals[1]
            
                answer = abs((p + q) * (p - q))
            
            # 4번째: 두개만 같고, 나머지는 다른 값
        elif len(values) == 3:
            if sorted(counts) == [1, 1, 2]:
                q = None
                r = None
                for v in values:
                    if num_list.count(v) == 1:
                        if q is None:
                            q = v
                        else:
                            r = v
                answer = q * r
                
            # 5번째: 모두 다 다른 값
        else:
            min_val = min(values)
            answer = min_val
        
    return int(answer)

if __name__ == "__main__":
    user_input = input()
    num_list = list(map(int, user_input.split(',')))
    
    result = solution(num_list)
    
    print(result)
```
**주요 개념 및 로직**
1. all_same이라는 플래그 선언 후, 리스트[0] 값과 비교하는 로직
2. values set을 만들고(중복 제거), set 원소별 count 리스트를 만듦
3. count 리스트를 통해 하나만 다른 값을 찾기
4. 마찬가지로, count 리스트를 통해 두 개의 값들 구별하기
5. 두 개는 같고, 나머지 두 개는 서로 다른 값일 때, q와 r에 None 값 할당 후, count가 1인 것 중, 비어있는 q에 먼저 할당
6. 모두 다 다른 값은 최소 값 배정
7. main에서는 list(), map(int, X) 메서드 사용

***
