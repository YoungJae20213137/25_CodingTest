# 기초 트레이닝 정리

[Python] 

모든 문제 번호는 '최신순' 정렬 되어 있는 문제들의 번호임.

## 함수(메서드)

### Q96(배열의 길이를 2의 거듭제곱으로 만들기) / 함수(메서드)
```Python
def power2(arr):
    power = 1
    
    while (power < len(arr)):
        power *= 2
        
    return power

def solution(arr):
    answer = []
    answer = arr
    
    power_val = power2(arr)
    padding = power_val - len(arr)
    
    answer.extend([0] * padding)
        
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    
    result = solution(arr)
    print(result)
```
**주요 개념 및 로직**
1. 우선 answer 리스트를 arr로 동일하게 맞춰준다.
2. arr의 길이가 2의 거듭제곱이 되게 하기 위해 power2 함수에 arr를 보내 현재 길이보다 큰 2의 거듭제곱만큼의 길이를 power 값에 담아 반환한다.
3. 그 값을 solution 함수에서 가져와 power_val에 담아주고, 남는 길이를 padding에 저장시켜, answer 리스트에 모자란 공간을 0으로 확장시킨다.

***

### Q97(배열 비교하기) / 함수(메서드)
```Python
# 굳이 함수를 또 만들 필요는 없지만, 메소드(함수)라는 문제 명목상 추가함
def compare(arr1, arr2):
    sum1, sum2 = 0, 0
    if (len(arr1) > len(arr2)):
        return 1
    elif (len(arr1) < len(arr2)):
        return -1
    elif (len(arr1) == len(arr2)):
        for num1, num2 in zip(arr1, arr2):
            sum1 += num1
            sum2 += num2
        if (sum1 > sum2):
            return 1
        elif (sum1 < sum2):
            return -1
        elif (sum1 == sum2):
            return 0
        
def solution(arr1, arr2):
    answer = 0
    answer = compare(arr1, arr2)
    
    return answer

if __name__ == "__main__":
    arr1 = list(map(int, input()))
    arr2 = list(map(int, input()))
    
    result = solution(arr1, arr2)
    print(result)
```
**주요 개념 및 로직**
1. answer 값을 가져오기 위해 compare 함수를 새로 만들어 거기에 arr1과 arr2를 보내 비교한다.
2. compare 함수에서는 arr1 리스트 원소의 합을 담을 sum1과, arr2 리스트 원소의 합을 담을 sum2를 0으로 초기화 해주고, 먼저 길이가 다를때부터의 조건문을 통해 1을 반환할지, -1을 반환할지를 결정한다.
3. 그 다음 길이가 같은 경우에, for문으로 arr1, arr2의 원소들의 합을 담아 sum1, sum2에 저장해주고, sum1과 sum2를 비교해 조건문으로 1을 반환할지, -1을 반환할지, 0을 반환할지를 결정한다.
4. 추가 고려할 점: Python에서 굳이 for문으로 sum 변수를 만들어서 담지 않아도, sum 메소드를 사용하면 바로 합이 담긴다.

***

### Q98(문자열 묶기) / 함수(메서드)
```Python
def parse_input_to_list(strArr):
    strArr = strArr.strip()[1:-1]
    parts = strArr.split('","')
    parts[0] = parts[0][1:] 
    parts[-1] = parts[-1][:-1] 
    
    return parts

def solution(re_strArr):
    answer = 0
    
    # for val in strArr:
        # length_list.append(len(val))
        
    freq = [0] * 31
    for val in re_strArr:
        l = len(val)
        freq[l] += 1
        
    max = 0
    for count in freq:
        if count > max:
            max = count
            
    answer = max
    
    return answer

if __name__ == "__main__":
    strArr = input()
    re_strArr = parse_input_to_list(strArr)
    result = solution(re_strArr)
    print(result)
```
**주요 개념 및 로직**
1. 먼저 strArr을 ","로 파싱해준 원소들을 parts 리스트에 저장하고, 첫 번째 원소의 "와 마지막 원소의 "를 제거해주고, parts를 반환한다.
2. main에서는 반환된 parts를 re_strArr로 담고, solution 함수로 보낸다.
3. solution 함수에서는 strArr에서의 원소의 길이가 30을 넘지 않기 때문에 길이를 담아줄 리스트에 30개의 공간을 할당하고 0으로 채운다.
4. 그리고 re_strArr에서의 각 값들을 순환하며 길이를 l에 저장, 그것을 인덱스로 활용하여 freq 리스트에 값을 더한다.
5. 각 인덱스가 결국에는 길이를 나타내고, 저장한 길이들 중에서 최댓값을 골라내야 하므로, 한번 더 for문으로 freq 리스트를 count 변수로 담아 순회하고, 최댓값을 찾는 로직으로 max에 가장 많이 나온 길이를 저장한다.
6. 그 값이 최종적으로 answer가 된다.
7. 길이 리스트를 생성할 때, strArr 원소의 길이가 30을 넘지 않는다는 점을 간과하면, 시간복잡도가 O(n^2)으로# 기초 트레이닝 정리

[Python] 

모든 문제 번호는 '최신순' 정렬 되어 있는 문제들의 번호임.

## 함수(메서드)

### Q96(배열의 길이를 2의 거듭제곱으로 만들기) / 함수(메서드)
```Python
def power2(arr):
    power = 1
    
    while (power < len(arr)):
        power *= 2
        
    return power

def solution(arr):
    answer = []
    answer = arr
    
    power_val = power2(arr)
    padding = power_val - len(arr)
    
    answer.extend([0] * padding)
        
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    
    result = solution(arr)
    print(result)
```
**주요 개념 및 로직**
1. 우선 answer 리스트를 arr로 동일하게 맞춰준다.
2. arr의 길이가 2의 거듭제곱이 되게 하기 위해 power2 함수에 arr를 보내 현재 길이보다 큰 2의 거듭제곱만큼의 길이를 power 값에 담아 반환한다.
3. 그 값을 solution 함수에서 가져와 power_val에 담아주고, 남는 길이를 padding에 저장시켜, answer 리스트에 모자란 공간을 0으로 확장시킨다.

***

### Q97(배열 비교하기) / 함수(메서드)
```Python
# 굳이 함수를 또 만들 필요는 없지만, 메소드(함수)라는 문제 명목상 추가함
def compare(arr1, arr2):
    sum1, sum2 = 0, 0
    if (len(arr1) > len(arr2)):
        return 1
    elif (len(arr1) < len(arr2)):
        return -1
    elif (len(arr1) == len(arr2)):
        for num1, num2 in zip(arr1, arr2):
            sum1 += num1
            sum2 += num2
        if (sum1 > sum2):
            return 1
        elif (sum1 < sum2):
            return -1
        elif (sum1 == sum2):
            return 0
        
def solution(arr1, arr2):
    answer = 0
    answer = compare(arr1, arr2)
    
    return answer

if __name__ == "__main__":
    arr1 = list(map(int, input()))
    arr2 = list(map(int, input()))
    
    result = solution(arr1, arr2)
    print(result)
```
**주요 개념 및 로직**
1. answer 값을 가져오기 위해 compare 함수를 새로 만들어 거기에 arr1과 arr2를 보내 비교한다.
2. compare 함수에서는 arr1 리스트 원소의 합을 담을 sum1과, arr2 리스트 원소의 합을 담을 sum2를 0으로 초기화 해주고, 먼저 길이가 다를때부터의 조건문을 통해 1을 반환할지, -1을 반환할지를 결정한다.
3. 그 다음 길이가 같은 경우에, for문으로 arr1, arr2의 원소들의 합을 담아 sum1, sum2에 저장해주고, sum1과 sum2를 비교해 조건문으로 1을 반환할지, -1을 반환할지, 0을 반환할지를 결정한다.
4. 추가 고려할 점: Python에서 굳이 for문으로 sum 변수를 만들어서 담지 않아도, sum 메소드를 사용하면 바로 합이 담긴다.

***

### Q98(문자열 묶기) / 함수(메서드)
```Python
def parse_input_to_list(strArr):
    strArr = strArr.strip()[1:-1]
    parts = strArr.split('","')
    parts[0] = parts[0][1:] 
    parts[-1] = parts[-1][:-1] 
    
    return parts

def solution(re_strArr):
    answer = 0
    
    # for val in strArr:
        # length_list.append(len(val))
        
    freq = [0] * 31
    for val in re_strArr:
        l = len(val)
        freq[l] += 1
        
    max = 0
    for count in freq:
        if count > max:
            max = count
            
    answer = max
    
    return answer

if __name__ == "__main__":
    strArr = input()
    re_strArr = parse_input_to_list(strArr)
    result = solution(re_strArr)
    print(result)
```
**주요 개념 및 로직**
1. 먼저 strArr을 ","로 파싱해준 원소들을 parts 리스트에 저장하고, 첫 번째 원소의 "와 마지막 원소의 "를 제거해주고, parts를 반환한다.
2. main에서는 반환된 parts를 re_strArr로 담고, solution 함수로 보낸다.
3. solution 함수에서는 strArr에서의 원소의 길이가 30을 넘지 않기 때문에 길이를 담아줄 리스트에 30개의 공간을 할당하고 0으로 채운다.
4. 그리고 re_strArr에서의 각 값들을 순환하며 길이를 l에 저장, 그것을 인덱스로 활용하여 freq 리스트에 값을 더한다.
5. 각 인덱스가 결국에는 길이를 나타내고, 저장한 길이들 중에서 최댓값을 골라내야 하므로, 한번 더 for문으로 freq 리스트를 count 변수로 담아 순회하고, 최댓값을 찾는 로직으로 max에 가장 많이 나온 길이를 저장한다.
6. 그 값이 최종적으로 answer가 된다.
7. 길이 리스트를 생성할 때, strArr 원소의 길이가 30을 넘지 않는다는 점을 간과하면, 시간복잡도가 O(n^2)으로 특정 값에서는 엄청나게 긴 시간이 요구될 수 있다. 따라서 freq 리스트를 30의 공간으로 제한한다.

***

### Q99(배열의 길이에 따라 다른 연산하기) / 함수(메서드)
```Python
def solution(arr, n):
    answer = []
    answer = arr
    
    if (len(arr) % 2 == 0):
        for i in range(1, len(arr), 2):
            answer[i] += n
    else:
        for i in range(0, len(arr), 2):
            answer[i] += n

    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    n = int(input())
    
    result = solution(arr, n)
    print(result)
```
**주요 개념 및 로직**
1. 우선 answer에 arr 리스트를 저장하고, arr 길이가 짝수 일때는 for문의 범위를 1부터 arr길이까지 2개씩 건너뛰며 arr[i] 값에 n을 더하고,
2. arr 길이가 홀수 일때는 for문의 범위를 0부터 arr길이까지 2개씩 건너뛰며 arr[i] 값에 n을 더한다.

***

### Q100(뒤에서 5등까지) / 함수(메서드)
```Python
def solution(num_list):
    answer = []
    
    num_list = sorted(num_list)
    answer = num_list[:5]
    
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(result)
```
**주요 개념 및 로직**
1. num_list를 오름차순 정렬하기 위해 sorted() 메소드를 사용하고, 그 후 answer 리스트에 num_list를 처음부터 5개만 가져오는 슬라이싱을 통해 저장한다.

***

### Q101(뒤에서 5등 위로) / 함수(메서드)
```Python
def solution(num_list):
    answer = []
    
    num_list = sorted(num_list)
    answer = num_list[5:]
    
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(result)
```
**주요 개념 및 로직**
1. 이번에도 num_list를 오름차순 정렬하고, 제일 작은 5개를 제외한 나머지를 추출하기 위해 [5:]로 슬라이싱하여 answer 리스트에 저장한다.

***

### Q102(전국 대회 선발 고사) / 함수(메서드)
```Python
def solution(rank, attendance):
    answer = 0
    temp = []
    
    # 알고리즘
    # 1. rank 배열에서 참가 가능한 인덱스, 값 골라내기
    # 2. 그 중에서 오름차순으로 정리(인덱스 포함)
    # 3. a, b, c로 인덱스 할당해서 최종 값 반환
    
    for index, (value, attend) in enumerate(zip(rank, attendance)):
        if (attend == True):
            temp.append((index, value))
    
    temp = sorted(temp, key=lambda x: x[1])
    
    answer = 10000 * temp[0][0] + 100 * temp[1][0] + temp[2][0]
    
    return answer

if __name__ == "__main__":
    rank = list(map(int, input()))
    attendance = list(input())
    
    result = solution(rank, attendance)
    print(result)
```
**주요 개념 및 로직**
1. rank, attendance 배열에서 참가 가능한 인덱스와 값을 저장할 temp 배열을 선언, temp 배열은 (index, value) 튜플 값을 가지는 리스트이다.
2. for index, (value, attend) in enumerate(zip(rank, attendance))를 사용해 rank와 attendance 배열을 하나로 묶은 튜플 상태에서 새로운 index 변수와 튜플로 for문을 돌린다.
3. 거기서 attend(튜플에서 attendance에 속한 변수)가 True인 것만 가져와 temp 리스트에 저장한다.
4. 그리고, 현재 temp는 (index, value) 튜플 형태로 값이 저장되어 있기 때문에, 오름차순 정렬을 하기 위해 key로 튜플의 열 값을 기준으로 정렬한다.
5. 이제 정렬된 temp에서 인덱스 값만 뽑아와서 answer 값을 저장, 반환한다.

***

### Q103(정수 부분) / 함수(메서드)
```Python
def solution(flo):
    answer = 0
    answer = int(flo)  
    return answer

if __name__ == "__main__":
    flo = float(input())
    
    result = solution(flo)
    print(result)
```
**주요 개념 및 로직**
1. flo 값을 받아서, int()로 감싸준 값을 answer에 저장해 반환한다.
2. 좋은 아이디어: flo // 1 을 하게 되면 1로 나누어 나머지는 버리고(소수점 이하는 버림) 몫(정수값)만 가져오게 되므로 더 빠르고 효율적이다.

***

### Q104(문자열 정수의 합) / 함수(메서드)
```Python
def solution(num_str):
    answer = 0
    
    for i in range(len(num_str)):
        answer += int(num_str[i])
    
    return answer

if __name__ == "__main__":
    num_str = input()
    
    result = solution(num_str)
    print(result)
```
**주요 개념 및 로직**
1. String 값을 배열로 생각하면, num_str 길이만큼 for문을 돌려 하나씩 값에 접근해 int로 변환 후 answer에 더해주고 반환한다.

***

### Q105(문자열을 정수로 변환하기) / 함수(메서드)
```Python
def solution(n_str):
    answer = 0
    answer = int(n_str)
    return answer

if __name__ == "__main__":
    n_str = input()
    
    result = solution(n_str)
    print(result)
```
**주요 개념 및 로직**
1. int(n_str)의 형태로 String을 Int로 변환해준다.

***

### Q106(0 떼기) / 함수(메서드)
```Python
def solution(n_str):
    answer = ''
    answer = n_str.lstrip('0')
    return answer

if __name__ == "__main__":
    n_str = input()
    
    result = solution(n_str)
    print(result)
```
**주요 개념 및 로직**
1. n_str.lstrip('0') 메소드를 사용해 왼쪽에 등장하는 첫 0 값들을 제거한다.

***

### Q107(두 수의 합) / 함수(메서드)
```Python
def solution(a, b):
    answer = ''
    answer = str(int(a) + int(b))
    return answer

if __name__ == "__main__":
    a, b = input()
    
    result = solution(a, b)
    print(result)
```
**주요 개념 및 로직**
1. Python에서는 정수형에 크기 제한이 없기 때문에 str(int(a) + int(b))의 형태로 써도 무관.

***

### Q108(문자열로 변환) / 함수(메서드)
```Python
def solution(n):
    answer = ''
    answer = str(n)
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(n)
```
**주요 개념 및 로직**
1. int n을 str(n)으로 스트링으로 변환

***
