# 기초 트레이닝 정리

[Python] 

모든 문제 번호는 '최신순' 정렬 되어 있는 문제들의 번호임.

## 리스트(배열)

### Q51(문자 개수 세기) / 리스트(배열)
```Python
def solution(my_string):
    answer = [0] * 52
    idx_list = []
    
    for i in range(26):
        A_idx = 65
        idx_list.append(A_idx + i)
    
    for j in range(26):
        a_idx = 97
        idx_list.append(a_idx + j)
        
    for ch in my_string:
        temp = ord(ch)
        if(temp in idx_list and temp <= 90):
            #0~25, 26~51
            answer[temp-65] += 1
        elif(temp in idx_list and temp >= 97):
            answer[temp-65-6] += 1
        
    return answer

if __name__ == "__main__":
    my_string = list(input())
    
    result = solution(my_string)
    
    print(result)
```
**주요 개념 및 로직**
1. 정답 리스트는 0으로 초기화해서 52칸의 공간 만들기
2. (A-Z, a-z)를 ASCII코드로 담아줄 idx_list 리스트 만들기
3. my_string을 글자별로 순회하며 idx_list에 있는지 검사하고, 있으면 해당 위치(대문자는 90까지, 소문자는 122까지)에 있는 카운트를 1씩 더함
4. 다시 생각해볼점: idx_list를 만들어 굳이 글자가 있는지 검사할 필요는 없다.

***

### Q52(배열 만들기 1) / 리스트(배열)
```Python
def solution(n, k):
    answer = []
    
    for i in range(1, n + 1):
        if(i % k == 0):
            answer.append(i)
    return answer

if __name__ == "__main__":
    n, k = map(int, input())
    
    result = solution(n, k)
    print(result)
```
**주요 개념 및 로직**
1. 1~n n이하의 정수 중에서 k의 배수인 것만 리스트에 담으면 되므로, 현재 숫자를 k로 나눈 나머지가 0인 것만 리스트에 저장

***

### Q53(글자 지우기) / 리스트(배열)
```Python
def solution(my_string, indices):
    answer = ''
    list(answer)
    my_string = list(my_string)
    indices = sorted(indices, reverse=True)
        
    for i in range(len(indices)):
        del my_string[indices[i]]
        
    # 잘못된 표기
    # for i in range(len(indices)):
        # my_string.remove(my_string[indices[i]])
        
    answer = my_string 
    
    return ''.join(answer)

if __name__ == "__main__":
    my_string = list(input())
    indices = list(map(int, input().split()))
    
    result = solution(my_string, indices)
    print(result)
```
**주요 개념 및 로직**
1. remove()와 del을 헷갈려서 고민한 문제: remove()는 값 기준으로 삭제하지만, my_string에서 특정 글자가 중복될 경우, 첫번째 값을 삭제하기 때문에 적절하지 않음 / 따라서 del로 인덱스 기준으로 삭제
2. 값을 삭제하면서 인덱스가 계속 바뀌기 때문에, indices 배열을 내림차순으로 정렬하기

***

### Q54(카운트 다운) / 리스트(배열)
```Python
def solution(start_num, end_num):
    answer = []
    
    for i in range(end_num, start_num + 1):
        answer.append(i)
    answer.reverse()

    return answer


if __name__ == "__main__":
    start_num = int(input())
    end_num = int(input())
    
    result = solution(start_num, end_num)
    print(result)
```
**주요 개념 및 로직**
1. 끝 숫자부터 시작 숫자까지 내림차순 정렬이므로 for문 쓸 때 반대로 입력해주고 마지막에 reverse()

***

### Q55(가까운 1 찾기) / 리스트(배열)
```Python
def solution(arr, idx):
    answer = 0
    temp = []
    
    for i in range(idx, len(arr)):
        if (arr[i] == 1):
            temp.append(i)
            
    if temp:
        answer = min(temp)
    else:
        answer = -1
        
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    idx = int(input())
    
    result = solution
    print(result)
```
**주요 개념 및 로직**
1. 주어진 인덱스부터 끝 원소까지 순회
2. 1이 있으면 temp 리스트에 저장
3. temp 리스트에 1이 하나라도 있으면 그 중에 가장 작은 인덱스를 answer에 저장
4. 아니라면 answer에는 -1

***

### Q56(리스트 자르기) / 리스트(배열)
```Python
def solution(n, slicer, num_list):
    answer = []
    
    a = slicer[0]
    b = slicer[1]
    c = slicer[2]
        
    if (n == 1):
        return num_list[:b+1]
    elif (n == 2):
        return num_list[a:]
    elif (n == 3):
        return num_list[a:b+1]
    elif (n == 4):
        return num_list[a:b+1:2]

if __name__ == "__main__":
    n = int(input())
    slicer = list(map(int, input()))
    num_list = list(map(int, input()))
    
    result = solution(n, slicer, num_list)
    
    print(result)
```
**주요 개념 및 로직**
1. 리스트 슬라이싱에서 마지막 원소를 제대로 포함하려면 +1
2. 2개 간격으로 자르려면, 마지막에 2 ex) [start:end:step]

***

### Q57(첫 번째로 나오는 음수) / 리스트(배열)
```Python
def solution(num_list):
    answer = 0
    
    for val in num_list:
        if (val < 0) :
            answer = num_list.index(val)
            return answer
    
    answer = -1
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(reulst)
```
**주요 개념 및 로직**
1. val이 음수인 것이 나오면 index를 return
2. 아니라면 -1 저장 후 return

***

### Q58(배열 만들기 3) / 리스트(배열)
```Python
def solution(arr, intervals):
    answer = []
    
    for i in intervals:
        for j in range(i[0], i[1] + 1):
            answer.append(arr[j])
            
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    intervals = list(map(int, input()))
    
    result = solution(arr, intervals)
    print(result)
```
**주요 개념 및 로직**
1. 2차원 배열일 때, 먼저 첫 i에 [1, 3], [0, 4]와 같은 리스트들을 담는다
2. 그리고 j에 1부터 3까지, 0부터 4까지 담아주고 그것을 asnwer 리스트에 이어붙임.

***

### Q59(2의 영역) / 리스트(배열)
```Python
def solution(arr):
    answer = []
    
    if 2 not in arr:
        answer.append(-1)
        return answer
    
    else:
        first_2_index = arr.index(2)
        last_2_index = len(arr) - 1 - arr[::-1].index(2)
        #또 다른 방법: last_2 = max(i for i, val in enumerate(arr) if val == 2)
        
        answer = arr[first_2_index:last_2_index + 1]
        return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    
    result = solution(arr)
    print(result)
```
**주요 개념 및 로직**
1. 첫 2가 나오는 인덱스(index())
2. 끝 2가 나오는 인덱스 구하는 방법(리스트 뒤집어서 구하고 전체 길이에서 빼주기)
3. 정답 리스트에 두 인덱스 범위만큼 합치기

***

### Q60(배열 조각하기) / 리스트(배열)
```Python
def solution(arr, query):
    answer = []

    #for ch in query:
        #if (query.index(ch) %2 == 0):
            # 짝수 일때
            #arr = arr[:arr.index(ch) + 1]
        #else:
            # 홀수 일때
            #arr = arr[arr.index(ch):]
            
    for i in range(len(query)):
        if i % 2 == 0:
            # 짝수 일때
            arr = arr[:query[i] + 1]
        else:
            # 홀수 일때
            arr = arr[query[i]:]
            
    answer = arr
    
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    query = list(map(int, input()))
    
    result = solution(arr, query)
    print(result)
```
**주요 개념 및 로직**
1. Query의 길이만큼 순서대로 진행:
2. i가 짝수일때는 처음부터 query[i] + 1까지 arr에 저장
3. i가 홀수일때는 query[i]부터 끝까지 arr에 저장

***

### Q61(n번째 원소부터) / 리스트(배열)
```Python
def solution(num_list, n):
    answer = []
    
    for i in range(n-1, len(num_list)):
        answer.append(num_list[i])
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    n = int(input())
    
    result = solution(num_list, n)
    print(result)
```
**주요 개념 및 로직**
1. 인덱스를 추출하기 위해 n번째가 되려면 n-1로 인덱스를 적용해서 n-1부터 num_list의 길이(끝 인덱스) 동안 반복해서 num_list의 인덱스를 추출하여 answer 리스트에 넣는다.

***

### Q62(순서 바꾸기) / 리스트(배열)
```Python
def solution(num_list, n):
    answer = []
    answer = num_list[n:len(num_list)] + num_list[:n]
    
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    n = int(input())
    
    result = solution(num_list, n)
    print(result)
```
**주요 개념 및 로직**
1. n번째 이후의 원소들은 [n:len(num_list)]로 슬라이싱,
2. n은 인덱스가 아니라 n번째를 나타내는 것
3. n번째까지의 원소들은 [:n]으로 슬라이싱
4. :n에서 n 인덱스는 포함 안되기 때문에 n번째까지라는 뜻
5. n+1번째는 포함 안됨

***

### Q63(왼쪽 오른쪽) / 리스트(배열)
```Python
def solution(str_list):
    answer = []
    
    # 특수 케이스 먼저 처리
    if (("l" in str_list) and ("r" not in str_list)):
        for i in range(0, str_list.index("l")):
                answer.append(str_list[i])
    elif (("l" not in str_list) and ("r" in str_list)):
        for i in range(str_list.index("r")+1, len(str_list)):
                answer.append(str_list[i])
                
    # r과 l 둘 다 있을 때
    elif (("l" in str_list) and ("r" in str_list)):
        # 먼저 나오는 문자열이 l일때
        if (str_list.index("l") < str_list.index("r")):
            for i in range(0, str_list.index("l")):
                answer.append(str_list[i])
        # 먼저 나오는 문자열이 r일때
        elif (str_list.index("r") < str_list.index("l")):
            for i in range(str_list.index("r")+1, len(str_list)):
                answer.append(str_list[i])
                
    # r과 l 둘 다 있지 않을 때
    elif (("l" not in str_list) and ("r" not in str_list)):
            answer = []
            
    return answer

if __name__ == "__main__":
    str_list = list(input().strip())
    
    result = solution(str_list)
    print(result)
```
**주요 개념 및 로직**
1. r과 l이 하나씩 있는 경우, 둘 다 있는 경우, 둘 다 없는 경우로 나눠서 조건문 분기함.
2. 다른 사람들이 푼 것을 보면, 더 효율적으로 풀 수 있는 방법이 있었음.
3. 시작부터 for문으로 l이 발견되면 슬라이싱으로 저장 후 반환
4. 마찬가지로 r이 발견되면 슬라이싱으로 저장 후 반환
5. 아니라면 [](빈 리스트)를 반환.

***

### Q64(n번째 원소까지) / 리스트(배열)
```Python
def solution(num_list, n):
    answer = []
    
    for i in range(0, n):
        answer.append(num_list[i])
        
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    n = int(input())
    
    result = solution(num_list, n)
    print(result)
```
**주요 개념 및 로직**
1. for문으로 n번째까지 answer에 저장하므로, 0번부터 시작하는 인덱스에서 마지막 n번째는 포함 안되고 그 전 인덱스까지 포함함.

***

### Q65(n개 간격의 원소들) / 리스트(배열)
```Python
def solution(num_list, n):
    answer = []
    
    num_list = num_list[::n]
    
    answer = num_list
        
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    n = int(input())
    
    result = solution(num_list, n)
    print(result)
```
**주요 개념 및 로직**
1. 슬라이싱의 step인자를 이용해, n만큼 떨어진 리스트를 새로 저장함.

***

### Q66(홀수 VS 짝수) / 리스트(배열)
```Python
def solution(num_list):
    answer = 0
    odd = 0
    even = 0
    
    for i in range(1, len(num_list)+1):
        if (i % 2 == 0):
            odd += num_list[i-1]
        else:
            even += num_list[i-1]
    
    if (odd > even):
        answer = odd
    else:
        answer = even
        
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(result)
```
**주요 개념 및 로직**
1. i 자체는 1부터 리스트 길이(끝 번호)까지 for문은 리스트 전체의 원소들을 홀수 -> 짝수 -> 홀수 -> 짝수 순으로 차례대로 비교하게 되면서 홀수의 합과 짝수의 합에 계속 더하게 된다.
2. 실제 값의 인덱스는 i-1번째에 속해있으므로 값을 더해준다.
3. 마지막에 홀수의 합과 짝수의 합을 비교하여 더 큰 값을 반환한다.

***

### Q67(5명씩) / 리스트(배열)
```Python
def solution(names):
    answer = []
    
    names = names[::5] 
    
    answer = names
    
    return answer

if __name__ == "__main__":
    names = list(input())
    
    result = solution(names)
    print(result)
```
**주요 개념 및 로직**
1. 65번 문제와 마찬가지로 슬라이싱에서 step 인자를 이용해 5명씩 끊어준 배열을 새로 저장하면 된다.

***

### Q68(할 일 목록) / 리스트(배열)
```Python
def solution(todo_list, finished):
    answer = []
    for i in range(0, len(finished)):
        if (finished[i] == 0):
            answer.append(todo_list[i])
    
    return answer

if __name__ == "__main__":
    todo_list = list(input().split(","))
    finished = list(map(bool, input()))
    
    result = solution(todo_list, finished)
    print(result)
```
**주요 개념 및 로직**
1. finished 리스트에서 bool 값이 false인 인덱스만 todo_list의 인덱스에 해당하는 값을 가져와 answer 리스트에 저장한다.

***

### Q69(n보다 커질 때까지 더하기) / 리스트(배열)
```Python
def solution(numbers, n):
    answer = 0
    
    for val in numbers:
        if (answer <= n):
            answer += val
    
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input()))
    n = int(input())
    
    result = solution(numbers, n)
    print(result)
```
**주요 개념 및 로직**
1. numbers 리스트의 원소들을 answer에 계속 합하다가, n보다 값이 커지면, 더 이상 answer에 더하지 않음.ㅅ

***

### Q70(수열과 구간 쿼리 1) / 리스트(배열)
```Python
def solution(arr, queries):
    answer = []
    
    for query in queries:
        s = query[0]
        e = query[1]
        for i in range(s, e+1):
            arr[i] += 1
        
    answer = arr
    
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    queries = list(input())
    
    result = solution(arr, queries)
    print(result)
```
**주요 개념 및 로직**
1. queries의 원소인 query 리스트들을 하나씩 순회하며 첫번째 값ㅇㄹ s, 두번째 값을 e로 저장하고,
2. 내부 for문에서 arr의 s부터 e 인덱스까지 전부 1을 더한다.

***

### Q71(조건에 맞게 수열 변환하기 1) / 리스트(배열)
```Python
def solution(arr):
    answer = []
    
    for i in range(0, len(arr)):
        if (arr[i] >= 50 and arr[i] % 2 == 0):
            arr[i] = arr[i] / 2
        elif (arr[i] < 50 and arr[i] % 2 != 0):
            arr[i] = arr[i] * 2
            
    answer = arr
    
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    
    result = solution(arr)
    print(result)
```
**주요 개념 및 로직**
1. i는 0번 인덱스부터 arr의 마지막 인덱스까지
2. 만약 arr의 인덱스에 해당하는 값이 50보다 크거나 같고 짝수라면 그 값을 2로 나누고,
3. 50보다 작고 홀수라면 그 값을 2를 곱한다,
4. 나머지는 그대로 유지한다.

***

### Q72(조건에 맞게 수열 변환하기 2) / 리스트(배열)
```Python
def solution(arr):
    answer = 0
    new_arr = []
    
    while (new_arr != arr):
        new_arr = []
        for k in range(0, len(arr)):
            new_arr.append(arr[k]) 
            
        for i in range(0, len(arr)):
            if (arr[i] >= 50 and arr[i] % 2 == 0):
                arr[i] = arr[i] / 2
            elif (arr[i] < 50 and arr[i] % 2 != 0):
                arr[i] = (arr[i] * 2) + 1
                
        answer += 1               
        
    return answer - 1

if __name__ == "__main__":
    arr = list(map(int, input()))
    
    result = solution(arr)
    print(result)
```
**주요 개념 및 로직**
1. 71번 문제의 로직은 그되로 쓰되, 새로운 new_arr를 만들어서 기존의 값과 비교하는 로직을 추가
2. whlie문으로 같아질 때, 구문을 종료하고, while문 내에서 new_arr는 빈 리스트로 계속 초기화되면서, 작업을 수행한 이전의 arr의 원소 값들로 채우고, 다시 arr는 새로운 작업을 수행하는 구문이다.
3. answer 플래그도 그에 맞춰 하나씩 증가되다가, new_arr과 arr가 같아지는 순간에 while문이 종료된다.
4. 그러나 이때의 answer 값은 마지막 반복까지 포함하여 종료된 값이므로 가장 작은 값을 반환하기 위해, 반환할때는 1을 차감하여 반환한다.

***

### Q73(1로 만들기) / 리스트(배열)
```Python
def solution(num_list):
    answer = 0
    temp = [0] * len(num_list)
    
    for i in range(0, len(num_list)):
        if (num_list[i] != 1):
            while (num_list[i] != 1):
                if (num_list[i] % 2 == 0):
                    num_list[i] = num_list[i] / 2
                    temp[i] += 1
                else:
                    num_list[i] = (num_list[i] - 1) / 2
                    temp[i] += 1  
        else:
            temp[i] = 0
        
    for val in temp:
        answer += val
        
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(result)
```
**주요 개념 및 로직**
1. 우선 num_list에 있는 원소들을 각각 나누기 연산을 실행한 합계를 저장할 temp 리스트를 0으로 초기화하여 num_list 길이만큼 선언해준다.
2. i는 0번 인덱스부터 num_list의 끝 인덱스만큼 순회하는데, 이때 num_list의 원소가 1이라면 temp 리스트의 해당 인덱스에도 합계는 0으로 기록이 되고,
3. 그게 아니라며 num_list의 원소가 1이 될 때까지 while문을 수행한다.
4. while문에서 num_list의 원소가 짝수라면 바로 2를 나누고 temp의 해당 인덱스에 해당하는 값에 1을 더한다.
5. num_list의 원소가 홀수라면 1을 빼서 2로 나누고 temp의 해당 인덱스에 해당하는 값에 1을 더하는 과정을 반복해서 num_list의 원소를 1로 만든다.
6. 그러면 temp 리스트에 해당하는 인덱스의 값은 num_list에 해당하는 인덱스의 값을 1로 만들기 위해 시행한 나누기의 횟수의 합이 담기게 된다.
7. 마지막에는 temp 리스트에 있는 값들을 전부 answer로 더해준다.

***

### Q74(길이에 따른 연산) / 리스트(배열)
```Python
def solution(num_list):
    answer = 0
    val = 1
    
    if (len(num_list) >= 11):
        val -= 1
        for i in range(0, len(num_list)):
            val += num_list[i]
    else:
        for i in range(0, len(num_list)):
            val *= num_list[i]
        
    answer = val
    
    return answer
            

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(result)
```
**주요 개념 및 로직**
1. 최초 val의 값을 1로 선언해주고(곱하기 계산 때문), num_list의 길이가 11이 넘어갈 경우, val은 0으로 초기화 후, num_list의 원소들의 합을 val에 저장해주고,
2. 10 이하일 경우, num_list의 원소들의 곱을 val에 저장해준다.
3. 마지막에 answer에 val 값을 저장해준다.

***

### Q92(배열의 원소만큼 추가하기) / 리스트(배열)
```Python
def solution(arr):
    answer = []
    
    for num in arr:
        for i in range(num):
            answer.append(num)
        
    return answer

if __name__ == "__main__":
    arr = input()
    
    result = solution(arr)
    print(result)
```
**주요 개념 및 로직**
1. arr의 한 숫자씩 num에 저장하고,
2. 이중 for문으로 안의 for문은 num 숫자의 범위만큼 반복하고, 반복할 동안 num을 num 숫자 범위만큼 answer에 이어붙인다.

***

### Q93(빈 배열에 추가, 삭제하기) / 리스트(배열)
```Python
def solution(arr, flag):
    answer = []
    
    for i in range(0, len(flag)):
        if (flag[i] == True):
            for r in range(arr[i] * 2):
                answer.append(arr[i])
        elif (flag[i] == False):
            for k in range(arr[i]):
                answer.pop()
        
    return answer

if __name__ == "__main__":
    arr = input()
    flag = input()
    
    result = solution(arr, flag)
    print(result)
```
**주요 개념 및 로직**
1. i의 범위를 flag 길이만큼 for문을 돌린다.
2. 만약 flag[i] 값이 true라면 arr[i] * 2 만큼 arr[i]를 answer에 붙인다.
3. 만약 flag[i] 값이 false라면 arr[i] 만큼 맨 뒤의 원소를 answer에서 제거한다.

***

### Q94(배열 만들기 6) / 리스트(배열)
```Python
def solution(arr):
    answer = []
    
    for i in range(0, len(arr)):
        if (len(answer) == 0):
            answer.append(arr[i])
            i += 1
        elif (len(answer) != 0 and answer[-1] == arr[i]):
            answer.pop()
            i += 1
        elif (len(answer) != 0 and answer[-1] != arr[i]):
            answer.append(arr[i])
            i += 1
    
    if (len(answer) == 0):
        return [-1]

    return answer

if __name__ == "__main__":
    arr = input()
    
    result = solution(arr)
    print(result)
```
**주요 개념 및 로직**
1. i의 범위를 arr의 길이만큼 for문을 돌린다.
2. 만약 stk이 빈 배열이라면 arr[i] 값을 넣고 i에 1을 더한다.
3. 만약 stk에 원소가 있고, stk의 마지막 값이 arr[i]와 같으면 마지막 원소를 stk에서 제거하고 i에 1을 더한다.
4. 만약 stk에 원소가 있고, stk의 마지막 값이 arr[i]와 다르면 arr[i] 값을 넣고 i에 1을 더한다.
5. 빈 배열이면 [-1]을 반환한다.

***

### Q95(무작위로 K개의 수 뽑기) / 리스트(배열)
```Python
def solution(arr, k):
    answer = []
    
    # 올바르지 않은 방법
    # if (len(answer) == 0): 
        # answer.append(arr[0]) 
        
    # for i in range(1, len(arr)): 
        # if (len(answer) < k and len(answer) > 0):
            # if (arr[i-1] != arr[i]): 
                # answer.append(arr[i]) 
        # else:
            # break    
            
    # if (len(answer) != k): 
        # while (len(answer) != k): 
            # answer.append(-1)
    
    # 올바른 방법
    for i in range(0, len(arr)):
        if (arr[i] not in answer):
            answer.append(arr[i])
        if (len(answer) == k):
            break
    
    if (len(answer) != k):
        while (len(answer) != k):
            answer.append(-1)
            
    return answer

if __name__ == "__main__":
    arr = list(map(int, input().split()))
    k = int(input())
    
    result = solution(arr, k)
    print(result)
```
**주요 개념 및 로직**
1. arr의 길이만큼 for문을 돌리는데, arr[i]가 answer 리스트 안에 없을 때만 answer에 arr[i] 값을 추가하고, 만약 answer 리스트의 길이가 k만큼 되었을 때는 반복문을 중단한다.
2. 그리고 만약 for문을 다 돌린 answer 리스트의 길이가 k만큼 충족되지 않았을 때는, k 길이가 되도록 부족한 공간에 -1을 채워넣는다.
3. 잘못 생각한 방법: 바로 앞과 현재 i의 값만 비교하여 전체적인 중복 제거가 되지 않았음.

***
