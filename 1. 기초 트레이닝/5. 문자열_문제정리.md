# 기초 트레이닝 정리

[Python] 

모든 문제 번호는 '최신순' 정렬 되어 있는 문제들의 번호임.

## 문자열

### Q38(글자 이어 붙여 문자열 만들기) / 문자열 

```Python
def solution(my_string, index_list):
    answer = []
    string_list = list(my_string)
    
    for val in index_list:
        answer.append(string_list[val])
        
    text = ''.join(answer)
    
    return text

if __name__ == "__main__":
    my_string = input().strip()
    index_list = list(map(int, input()))
    
    result = solution(my_string, index_list)
    
    print(result)
```
**주요 개념 및 로직**
1. string을 리스트로 변환 -> list() 사용
2. list를 다시 string으로 변환 -> ''.join() 사용 (공백 없이 이어붙이기)

***

### Q39(9로 나눈 나머지) / 문자열
```Python
def solution(number):
    digit_sum = 0
    for digit in number:
        digit_sum += int(digit)
    answer = digit_sum % 9
    return answer

if __name__ == "__main__":
    number = input()
    result = solution(number)
    
    print(result)
```
**주요 개념 및 로직**
1. number 문자열에서 자릿수 별로 int 변환해서 더하기

***

### Q40(문자열 여러 번 뒤집기) / 문자열
```Python
def solution(my_string, queries):
    answer = ''
    str = list(my_string)
    
    for i, j in queries:
        str[i:j+1] = reversed(str[i:j+1])
    
    answer = ''.join(str)
                
    return answer

if __name__ == "__main__" :
    my_string = input()
    queries = input()
    
    result = solution(my_string, queries)
    
    print(result)
```
**주요 개념 및 로직**
1. 문자열을 리스트로 변환
2. 리스트 슬라이싱(끝 부분 포함 안됨)
3. 다시 스트링 변환

***

### Q41(배열 만들기 5) / 문자열
```Python
def solution(intStrs, k, s, l):
    answer = []
    
    for val in intStrs:
        if int(val[s:s+l]) > k:
            answer.append(int(val[s:s+l]))
    return answer

if __name__ == "__main__":
    intStrs = list(map(int, input().strip()))
    k, s, l = input()
    
    result = solution(intStrs, k, s, l)
    
    print(result)
```
**주요 개념 및 로직**
1. 처음 string으로 받은 배열 int로 매핑, 공백 제거
2. 원소값 슬라이싱할 때, s: 시작 위치, s+l: 끝 위치 지정
3. k(int) 값과 비교를 위해 int 변환

***

### Q42(부분 문자열 이어 붙여 문자열 만들기) / 문자열
```Python
def solution(my_strings, parts):
    answer = ''
    answer = list(answer)
    k = 0
    
    for string in my_strings:
        i, j = parts[k]
        answer.append(string[i:j+1])
        k = k + 1

    result = ''.join(answer)
        
    return result

if __name__ == "__main__":
    my_strings = list(input())
    parts = list(input())
    
    result = solution(my_strings, parts)
    
    print(result)
```
**주요 개념 및 로직**
 1. my_strings와 parts 리스트 변환
 2. string 원소들을 parts에 있는 0번째 원소(i: 시작, j: 끝)부터 my_strings에 있는 원소 개수 까지 슬라이싱
 3. 초기 k 값은 증가
 4. 마지막에 answer 리스트를 string으로 변환해서 결과 반환

***

### Q43(문자열의 뒤의 n글자) / 문자열
```Python
def solution(my_string, n):
    answer = ''
    answer = my_string[-n:]
    return answer

if __name__ == "__main__":
    my_string = list(input())
    n = input()
    
    result = solution(my_string, n)
    
    print(result)
```
**주요 개념 및 로직**
1. [-n:]은 뒤에서부터 n번째부터 끝까지 슬라이싱

***

### Q44(접미사 배열) / 문자열
```Python
def solution(my_string):
    answer = []
    
    for i in range(len(my_string)):
        char = my_string[-i:]
        answer.append(char)
        
    answer = sorted(answer)
    return answer

if __name__ == "__main__":
    my_string = list(input())
    
    result = solution(my_string)
    
    print(result)
```
**주요 개념 및 로직**
1. i 값에는 입력된 my_string의 길이가 하나씩 담기게 됨
2. char에는 접미사가 저장, answer 배열에 하나씩 담기게 됨
3. sorted()로 사전 정렬 가능

***

### Q45(접미사인지 확인하기) / 문자열
```Python
def solution(my_string, is_suffix):
    answer = 0
    comp = []
    
    # 접미사 리스트 만들기
    for i in range(len(my_string)):
        comp.append(my_string[-i:])
        
    # is_suffix와 비교
    if(is_suffix in comp):
        answer = 1
    else:
        answer = 0
    
    return answer

if __name__ == "__main__":
    my_string = list(input())
    is_suffix = input()
    
    result = solution(my_string, is_suffix)
    
    print(result)
```
**주요 개념 및 로직**
1. 44번 문제처럼 접미사 배열 만들기
2. in을 사용해서 is_suffix가 리스트에 있는지 검사

***

### Q46(문자열의 앞의 n글자) / 문자열
```Python
def solution(my_string, n):
    answer = '' 
    answer = str(my_string[:n])
    
    return answer

if __name__ == "__main__":
    my_string = list(input())
    n = input()
    
    result = solution(my_string, n)
    
    print(result)
```
**주요 개념 및 로직**
1. [:n]은 처음부터 n자리까지 추출

***

### Q47(접두사인지 확인하기) / 문자열
```Python
def solution(my_string, is_prefix):
    answer = 0
    comp = []
    
    # 접두사 리스트
    for i in range(len(my_string)):
        comp.append(my_string[:i])
        
    # is_prefix와 비교
    if(is_prefix in comp):
        answer = 1
    else:
        answer = 0
    
    return answer

if __name__ == "__main__":
    my_string = list(input())
    is_prefix = input()
    
    result = solution(my_string, is_prefix)
    
    print(result)
```
**주요 개념 및 로직**
1. 45번 문제와 유사
2. 접두사 배열 만들기
3. in을 사용해서 is_suffix가 리스트에 있는지 검사

***

### Q48(문자열 뒤집기) / 문자열
```Python
def solution(my_string, s, e):
    answer = ''
    answer = my_string[:s] + my_string[s:e+1][::-1] + my_string[e+1:]
    
    return answer

if __name__ == "__main__":
    my_string = list(input())
    s, e = input()
    
    result = solution(my_string, s, e)
    
    print(result)
```
**주요 개념 및 로직**
1. 문자열의 일부분을 뒤집고 싶을 때
2. 처음부터 뒤집는 부분의 시작위치까지 슬라이싱
3. 뒤집는 부분의 시작 위치:끝 위치+1까지 슬라이싱 후, -1 step으로 뒤집기
4. 끝 위치+1부터 끝까지 슬라이싱
5. 슬라이싱 한 부분 다 더하기

***

### Q49(세로 읽기) / 문자열
```Python
def solution(my_string, m, c):
    answer = ''
    answer = list(answer)
    
    # 빈 행렬 만들기
    matrix = []
    
    # 열 개수는 m, 행 개수는 문자열 길이 따라 자동 적용
    cols = m
    rows = (len(my_string) + cols - 1) // cols
    
    for i in range(rows):
        row = [] # 각 행마다 빈 리스트 계속 만들어주기
        for j in range(cols):
            idx = i * cols + j # 각 행의 몇번째 열(인덱스)
            if idx < len(my_string):
                row.append(my_string[idx])
            else:
                row.append('')
        matrix.append(row)
        
    # 세로 읽기
    c -= 1
    for r in range(rows):
        answer.append(matrix[r][c])
        
    return ''.join(answer)

if __name__ == "__main__":
    my_string = input()
    m, c = map(int, input().split())
    
    result = solution(my_string, m, c)
    
    print(result)
```
**주요 개념 및 로직**
1. 열 개수는 사용자에게 입력 받지만, 행 개수는 올림 나누기를 통해 획득 (x + y - 1 // y)
2. 행렬 생성(각 행마다 빈 리스트 생성, 각 행에서 열들을 채우기 위해, 문자열의 인덱스를 이용(몇 번째 행의 몇 번째 열 공식: i * cols + j)
3. 얻은 인덱스로 값을 채우기 전, 스트링의 전체 길이와 생성한 행렬에서의 마지막 행의 차이를 비교하여 값을 채울지, 빈 문자열을 채울지 로직을 구현 -> 최종 값 채우기
4. 생성한 행렬에서 행 값(-1 : 0부터 시작함)을 이용해 사용자에게 입력받은 열 값으로 전체 행을 순회하며 문자를 가져와서 answer 리스트에 저장
5. 반환은 string으로

***

### Q50(qr code) / 문자열
```Python
def solution(q, r, code):
    answer = ''
    answer = list(answer)
    
    matrix = []
    
    # 행과 열 값
    cols = q
    rows = (len(code) + cols - 1) // cols
    
    # matrix 생성
    for i in range(rows):
        row = []
        for j in range(cols):
            idx = i * cols + j
            if idx < len(code):
                row.append(code[idx])
            else:
                row.append('')
        matrix.append(row)
    
    # 나머지가 r인(열이 r인) 값들 모으기
    for k in range(rows):
        if matrix[k][r] != '':
            answer.append(matrix[k][r])
        
    return ''.join(answer)

if __name__ == "__main__":
    q, r = map(int, input().split())
    code = list(input())
    
    result = solution(q, r, code)
    
    print(result)
```
**주요 개념 및 로직**
1. 49번 문제와 유사
2. 행, 열 값을 만들고, 주어진 스트링을 기반으로 행렬을 생성
3. 전체 스트링의 길이를 주어진 열값만큼 나누었을 때의 각 행마다 나머지 열의 위치에 있는 값들을 모으기

***

### Q75(원하는 문자열 찾기) / 문자열
```Python
def solution(myString, pat):
    answer = 0
    
    myString = myString.lower()
    pat = pat.lower()
    
    if (pat in myString):
        answer = 1
    else:
        answer = 0
    
    return answer

if __name__ == "__main__":
    myString = input()
    pat = input()
    
    result = solution(myString, pat)
    print(result)
```
**주요 개념 및 로직**
1. 알파벳 대소문자는 구분하지 않는다고 했으므로, myString과 pat 문자열 모두 소문자로 맞춰주고,
2. pat 문자열이 myString에 있는지 비교하기 위해, if (pat in myString)으로 비교한다.

***

### Q76(대문자로 바꾸기) / 문자열
```Python
def solution(myString):
    answer = ''
    myString = myString.upper()
    
    answer = myString
    return answer

if __name__ == "__main__":
    myString = input()
    
    result = solution(myString)
    print(result)
```
**주요 개념 및 로직**
1. 모든 알파벳을 대문자로 변환해야 하므로 myString.upper() 메소드를 사용한다.

***

### Q77(소문자로 바꾸기) / 문자열
```Python
def solution(myString):
    answer = ''
    myString = myString.lower()
    
    answer = myString
    return answer

if __name__ == "__main__":
    myString = input()
    
    result = solution(myString)
    print(result)
```
**주요 개념 및 로직**
1. 이번엔 모든 알파벳을 소문자로 변환해야 하므로 myString.lower() 메소드를 사용한다.

***

### Q78(배열에서 문자열 대소문자 변환하기) / 문자열
```Python
def solution(strArr):
    answer = []
    
    for i in range(0, len(strArr)):
        if (i % 2 == 0):
            strArr[i] = strArr[i].lower()
        else:
            strArr[i] = strArr[i].upper()
            
    answer = strArr
    return answer

if __name__ == "__main__":
    strArr = input()
    
    result = solution(strArr)
    print(result)
```
**주요 개념 및 로직**
1. for i in range를 이용해서 0부터 strArr의 끝 인덱스까지 i가 짝수이면 strArr[i]의 값을 lower() 메소드를 이용하여 소문자로,
2. i가 홀수이면 strArr[i]의값을 upper() 메소드를 이용하여 대문자로 바꿔준다.

***

### Q79(A 강조하기) / 문자열
```Python
def solution(myString):
    answer = ''
    myString = list(myString)
    
    for i in range(0, len(myString)):
        if (myString[i] == 'a' or myString[i] == 'A'):
            myString[i] = myString[i].upper()
        else:
            myString[i] = myString[i].lower()
            
        answer = ''.join(myString)
    return answer

if __name__ == "__main__":
    myString = list(input())
    
    result = soluton(myString)
    print(result)
```
**주요 개념 및 로직**
1. 먼저 myString을 리스트로 변환해주고, for i in range를 이용해서 0부터 myString의 끝 인덱스까지 조회하는데,
2. 만약 값이 a나 A면 그 값을 upper() 메소드를 이용해서 대문자로 변환해주고,
3. 만약 값이 다른 것이면 그 값을 lower() 메소드를 이용해서 소문자로 변환해준다.
4. 그리고 마지막에는 ''.join(myString)을 이용해서 리스트를 다시 string으로 이어붙여주고 answer에 저장한다.

***

### Q80(특정한 문자를 대문자로 바꾸기) / 문자열
```Python
def solution(my_string, alp):
    answer = ''
    my_string = list(my_string)
    
    for i in range(0, len(my_string)):
        if (my_string[i] == alp):
            my_string[i] = my_string[i].upper()     
    
    answer = ''.join(my_string)
    return answer

if __name__ == "__main__":
    my_string = input()
    alp = input()
    
    result = solution(my_string, alp)
    print(result)
```
**주요 개념 및 로직**
1. 마찬가지로 my_string을 리스트로 바꿔주고 for i in range를 이용해서 0부터 my_string의 끝 인덱스까지 조회하는데,
2. 만약 값이 alp이면 그 값을 upper() 메소드를 이용해서 대문자로 변환해준다.
3. 마지막에는 ''.join(my_string)을 이용해서 리스트를 다시 string으로 이어붙여주고 answer에 저장한다.

***

### Q81(특정 문자열로 끝나는 가장 긴 부분 문자열 찾기) / 문자열
```Python
def solution(myString, pat):
    answer = ''
    temp = []
    
    start = 0
    while True:
        idx = myString.find(pat, start)
        if idx == -1:
            break
        temp.append(idx)
        start = idx + 1
    
    max_idx = max(temp)
    
    myString = myString[:max_idx] + pat
    
    answer = myString
    
    
    return answer

if __name__ == "__main__":
    myString = input()
    pat = input()
    
    result = solution(myString, pat)
    print(result)
```
**주요 개념 및 로직**
1. pat 문자열이 등장하는 가장 마지막 인덱스를 찾기 위해서 while문으로 temp 리스트에 pat이 등장하는 인덱스들을 모두 저장
2. 그 중 max_idx로 가장 큰 인덱스를 저장
3. myString은 처음부터 가장 큰 인덱스까지 + pat 문자열로 새로 저장해준다.
4. 그 값이 answer

***

### Q82(문자열이 몇 번 등장하는지 세기) / 문자열
```Python
def solution(myString, pat):
    answer = 0
    
    # count 방식은 중첩되는 결과는 배제함
    # answer = myString.count(pat)
    
    # 대신에 이런 방식
    start = 0
    
    while True:
        idx = myString.find(pat, start)
        if idx == -1:
            break
        start = idx + 1
        answer += 1
    
    return answer

if __name__ == "__main__":
    myString = input()
    pat = input()
    
    result = solution(myString, pat)
    print(result)
```
**주요 개념 및 로직**
1. myString.count() 메소드를 사용하면 중복되는 인덱스(ex) banana에서 ana는 2개 있지만 1개로 측정)는 배제되기 때문에 다른 로직을 사용한다.
2. 81번 문제와 동일한 find() 메소드를 이용한 로직에서 idx가 끝나면 while문은 종료, 아니라면 찾는 문자열이 있는 인덱스를 하나씩 더해가며, 있을 때마다 count의 숫자도 하나 더한다.

***

### Q83(ad 제거하기) / 문자열
```Python
def solution(strArr):
    answer = []
    
    for str in strArr:
        if ("ad" not in str):
            answer.append(str)
    
    return answer

if __name__ == "__main__":
    strArr = input()
    
    result = solution(strArr)
    print(result)
```
**주요 개념 및 로직**
1. strArr 리스트의 string 원소들을 순회하면서, "ad"라는 문자열이 없는 원소(str)만 answer 리스트에 저장한다.

***

### Q84(공백으로 구분하기 1) / 문자열
```Python
def solution(my_string):
    answer = []
    answer = my_string.split(' ')
        
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. Python의 split() 메소드를 이용하면 아주 간단한 문제이다.
2. my_string 문자열을 split(' ') 즉, 공백으로 구분해서 answer 리스트에 저장한다는 의미.

***

### Q85(공백으로 구분하기 2) / 문자열
```Python
def solution(my_string):
    answer = []
    answer = my_string.split()
    
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. Python의 split() 메소드를 한 번 더 이용한다.
2. 이번에는 split() 메소드 안에 ' '와 같은 특정 인자를 사용하지 않고, split()만 사용하면 된다.
3. 특정 인자를 주지 않으면, 메소드는 연속된 공백은 하나의 공백으로 처리하게 되어, 분리할 수 있게 된다.

***

### Q86(x 사이의 개수) / 문자열
```Python
def solution(myString):
    answer = []
    temp = []
    
    temp = myString.split('x')
    
    for val in temp:
        answer.append(len(val))
        
    return answer

if __name__ == "__main__":
    myString = input()
    
    result = solution(myString)
    print(result)
```
**주요 개념 및 로직**
1. 빈 리스트(temp)를 만들고 거기에 myString의 문자들을 'x' 문자로 구분하여 리스트에 저장한다.
2. 그리고 temp 리스트를 하나씩 순회하며 각 원소들의 길이를 len() 메소드로 측정하여 answer 리스트에 저장한다.

***

### Q87(문자열 잘라서 정렬하기) / 문자열
```Python
def solution(myString):
    answer = []
    myString = sorted(myString.split('x'))
    answer = [i for i in myString if i.strip() != '']
    
    return answer

if __name__ == "__main__":
    myString = input()
    
    result = solution(myString)
    print(result)
```
**주요 개념 및 로직**
1. myString을 x로 분리하여 사전 순으로 정렬하여 저장한다.
2. 그 중, 공백이 있는 것은 strip() 메소드로 정리하고 answer 리스트에 넣는다.

***

### Q88(간단한 식 계산하기) / 문자열
```Python
def solution(binomial):
    answer = 0
    
    binomial = binomial.split(' ')
    a = int(binomial[0])
    op = binomial[1]
    b = int(binomial[2])
    
    if (op == '+'):
        answer = a + b
    elif (op == '-'):
        answer = a - b
    elif (op == '*'):
        answer = a * b
    
    return answer

if __name__ == "__main__":
    binomial = input()
    
    result = solution(binomial)
    print(result)
```
**주요 개념 및 로직**
1. binomial 문자열은 'a op b' 형태로 주어지므로, 공백을 기준으로 분리하여 binomial 리스트에 저장한다.
2. a는 binomial 첫 번째 원소를 정수형으로, op는 binomial 두 번째 원소, b는 binomial 세 번째 원소에 정수형으로 저장한다.
3. op가 어떤 연산자인지에 따라서 조건문으로 분기하여 answer에 저장한다.

***

### Q89(문자열 바꿔서 찾기) / 문자열
```Python
def solution(myString, pat):
    answer = 0
    
    myString = myString.replace('A', '#').replace('B', 'A').replace('#', 'B')
    
    if (pat in myString):
        answer = 1
    else:
        answer = 0
        
    return answer

if __name__ == "__main__":
    myString = input()
    pat = input()
    
    result = solution(myString, pat)
    print(result)
```
**주요 개념 및 로직**
1. 먼저 myString을 replace() 메소드를 이용해 A를 #으로, B를 A로, #을 B로 바꿔준다.
2. 그리고 pat이라는 문자열이 myString에 있으면 answer에 1을, 없으면 0으로 저장한다.

***

### Q90(rny_string) / 문자열
```Python
def solution(rny_string):
    answer = ''
    
    rny_string = list(rny_string)
    
    for i, ch in enumerate(rny_string):
        if (ch == 'm'):
            rny_string[i] = 'rn'
            
    answer = ''.join(rny_string)
    
    return answer

if __name__ == "__main__":
    rny_string = input()
    
    result = solution(rny_string)
    print(result)
```
**주요 개념 및 로직**
1. rny_string을 리스트로 변환하고, for enumerate(rny_string)에 i와 ch로 돌린다.
2. i에는 인덱스가 담기고, ch에는 인덱스에 맞는 문자 하나가 담긴다.
3. 그걸 이용해서 문자가 m일때, 해당 인덱스에 있는 값을 rn으로 바꾸는 작업을 수행한다.
4. 마지막에 answer에 rny_string을 이어붙여 문자열로 만든 값을 저장한다.

***

### Q91(세 개의 구분자) / 문자열
```Python
import re

def solution(myStr):
    answer = []
    answer = re.split('[abc]', myStr)
    answer = [s for s in answer if s != '']
    if len(answer) == 0:
        return ["EMPTY"]

    # 다른 풀이
    # answer = [x for x in myStr.replace('a', ' ').replace('b', ' ').replace('c', ' ').split() if x]
    # return answer if answer else ['EMPTY']
    
    return answer

if __name__ == "__main__":
    myStr = input()
    
    result = solution(myStr)
    print(result)
```
**주요 개념 및 로직**
1. 정규표현 라이브러리를 불러와서 a와 b와 c 문자열 기준으로 동시에 split을 하고,
2. 공백이 있으면 제거하고 answer 리스트에 저장한다.
3. 만약 빈 리스트면 ["EMPTY"] 리스트를 반환한다.
4. 다른 풀이는 answer 리스트에 myStr 리스트에서 'a'와 'b'와 'c'를 공백으로 바꾸고, 공백을 제거한 후에 저장하고, 비어있으면 ["EMPTY"] 리스트를 반환하는 로직이다.

***
