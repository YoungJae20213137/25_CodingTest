# 기초 트레이닝 정리

[Python] 

모든 문제 번호는 '최신순' 정렬 되어 있는 문제들의 번호임.

## 이차원 리스트(배열)

### Q120(특별한 이차원 배열 1) / 이차원 리스트(배열)
```Python
def solution(n):
    answer = [[]]
    
    for i in range(n):
        row = []
        for j in range(n):
            if (i == j):
                row.append(1)
            else:
                row.append(0)
                
        answer.append(row)
                
    return answer[1:]

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 이 문제는 단위 행렬을 만드는 문제: 더 간단한 방법이 존재하나, 정석적인 방법으로 접근
2. 먼저 answer = [[]] 기본 바탕을 선언.
3. 첫 번째 for문에서 빈 리스트(row(행)) 선언 후 두 번째 for문에서 i와 j가 같으면 1을 행에 넣고, 아니면 0을 넣는 작업을 반복한다.
4. 행 작업이 끝나면 answer에 이어붙인다. 계속 반복 후, 모든 작업이 끝나면 첫 [] 리스트는 버리고 반환.

***

### Q121(정수를 나선형으로 배치하기) / 이차원 리스트(배열)
```Python
def solution(n):
    answer = [[0] * n for _ in range(n)] # n X n 배열 0으로 초기화
    
    # 방향 (오른쪽, 아래쪽, 왼쪽, 위쪽)
    directions = [(0,1), (1,0), (0,-1), (-1,0)]
    dir_idx = 0 # 현재 방향 인덱스
    x, y = 0, 0 # 시작 위치(실제 위치)
    
    for num in range(1, n*n + 1):
        answer[x][y] = num
        dx, dy = directions[dir_idx]
        nx, ny = x + dx, y + dy # 다음 위치: 현재 위치에서 다음 방향 인덱스에 해당하는 값으로 더하기
        
        # x가 0보다 작거나, n보다 크거나, y가 0보다 작거나 n보다 크거나(범위 초과), 이미 채워졌으면 방향 바꾸기
        if (nx < 0 or nx >= n or ny < 0 or ny >= n or answer[nx][ny] != 0):
            dir_idx = (dir_idx + 1) % 4
            dx, dy = directions[dir_idx] # 다음 방향 인덱스 가져와서 dx, dy에 할당
            nx, ny = x + dx, y + dy
        
        # 그 다음 for문을 위해 실제 위치에 할당
        x, y = nx, ny
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(n)
```
**주요 개념 및 로직**
1. 먼저 n X n 배열을 0으로 초기화한다.
2. 방향 튜플을 선언해준다. 순서대로 오른쪽, 아래쪽, 왼쪽, 위쪽: 배열의 움직임별로 정리
3. 현재 방향 인덱스(처음은 0번(오른쪽))와, 시작 위치(처음은 answer[0][0])를 선언해준다.
4. 1부터 n*n까지 채워주기 위해 for문을 돌린다.
5. 먼저 현재 방향값 dx, dy를 선언해서, directions 튜플의 첫번째 값(현재 방향 인덱스)을 가져와서 할당한다.
6. 다음 방향값 nx, ny를 선언해서, 시작 위치(실제 위치)에서 방향값을 더해준 값을 할당한다.
7. num 값들을 채우다가 다음과 같은 상황에서 방향 인덱스를 바꾼다: nx(다음 열값)가 0보다 작아지거나 nx가 n보다 커지거나, ny(다음 행값)가 0보다 작아지거나 ny가 n보다 커지거나, 그리고 answer 행렬이 이미 채워진 값이라면(0이 아니라면)
8. 현재 방향 인덱스에 다음 방향 인덱스를 할당하고, 현재 방향값 dx, dy에 다음 튜플 값을 할당해준다.
9. 다음 방향값 nx, ny에 실제 위치에서 방향값 dx, dy를 더해준 값을 할당한다.
10. 그 다음 for문을 돌리기 위해 answer배열에 들어가는 x, y(실제 위치)에 nx, ny를 할당한다.
11. for문이 다 돌아가고나면 answer에는 나선형으로 num들이 배치되어있다.

***

### Q122(특별한 이차원 배열 2) / 이차원 리스트(배열)
```Python
def solution(arr):
    answer = 0
    k = len(arr)
    flag = []
    
    for i in range(k):
        for j in range(k):
            if (arr[i][j] == arr[j][i]):
                flag.append(1)
            else:
                flag.append(0)
                
    if 0 in flag:
        answer = 0
    else:
        answer = 1
        
    return answer

if __name__ == "__main__":
    arr = input()
    
    result = solution(arr)
    print(result)
```
**주요 개념 및 로직**
1. 먼저 arr의 길이를 k, 빈 리스트 flag를 선언해주고,
2. 이차원 리스트 arr의 행 원소를 i, 열 원소를 j로 선언한 이중 for문에서,
3. arr[i][j]와 arr[j][i] 값이 같다면 flag 리스트에 1을 넣고, 아니라면 0을 넣는다.
4. flag 값들을 순서는 중요한 것이 아니므로, 0이 하나라도 발견된다면 answer에는 0, 0이 하나도 없다면 1을 할당하고, 반환한다.

***

### Q123(정사각형으로 만들기) / 이차원 리스트(배열)
```Python
