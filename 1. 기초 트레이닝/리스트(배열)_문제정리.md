# 기초 트레이닝 정리

[Python] 

## 리스트(배열)

### Q51(문자 개수 세기) / 리스트(배열)
```Python
def solution(my_string):
    answer = [0] * 52
    idx_list = []
    
    for i in range(26):
        A_idx = 65
        idx_list.append(A_idx + i)
    
    for j in range(26):
        a_idx = 97
        idx_list.append(a_idx + j)
        
    for ch in my_string:
        temp = ord(ch)
        if(temp in idx_list and temp <= 90):
            #0~25, 26~51
            answer[temp-65] += 1
        elif(temp in idx_list and temp >= 97):
            answer[temp-65-6] += 1
        
    return answer

if __name__ == "__main__":
    my_string = list(input())
    
    result = solution(my_string)
    
    print(result)
```
**주요 개념 및 로직**
1. 정답 리스트는 0으로 초기화해서 52칸의 공간 만들기
2. (A-Z, a-z)를 ASCII코드로 담아줄 idx_list 리스트 만들기
3. my_string을 글자별로 순회하며 idx_list에 있는지 검사하고, 있으면 해당 위치(대문자는 90까지, 소문자는 122까지)에 있는 카운트를 1씩 더함
4. 다시 생각해볼점: idx_list를 만들어 굳이 글자가 있는지 검사할 필요는 없다.

***

### Q52(배열 만들기 1) / 리스트(배열)
```Python
def solution(n, k):
    answer = []
    
    for i in range(1, n + 1):
        if(i % k == 0):
            answer.append(i)
    return answer

if __name__ == "__main__":
    n, k = map(int, input())
    
    result = solution(n, k)
    print(result)
```
**주요 개념 및 로직**
1. 1~n n이하의 정수 중에서 k의 배수인 것만 리스트에 담으면 되므로, 현재 숫자를 k로 나눈 나머지가 0인 것만 리스트에 저장

***

### Q53(글자 지우기) / 리스트(배열)
```Python
def solution(my_string, indices):
    answer = ''
    list(answer)
    my_string = list(my_string)
    indices = sorted(indices, reverse=True)
        
    for i in range(len(indices)):
        del my_string[indices[i]]
        
    # 잘못된 표기
    # for i in range(len(indices)):
        # my_string.remove(my_string[indices[i]])
        
    answer = my_string 
    
    return ''.join(answer)

if __name__ == "__main__":
    my_string = list(input())
    indices = list(map(int, input().split()))
    
    result = solution(my_string, indices)
    print(result)
```
**주요 개념 및 로직**
1. remove()와 del을 헷갈려서 고민한 문제: remove()는 값 기준으로 삭제하지만, my_string에서 특정 글자가 중복될 경우, 첫번째 값을 삭제하기 때문에 적절하지 않음 / 따라서 del로 인덱스 기준으로 삭제
2. 값을 삭제하면서 인덱스가 계속 바뀌기 때문에, indices 배열을 내림차순으로 정렬하기

***

### Q54(카운트 다운) / 리스트(배열)
```Python
def solution(start_num, end_num):
    answer = []
    
    for i in range(end_num, start_num + 1):
        answer.append(i)
    answer.reverse()

    return answer


if __name__ == "__main__":
    start_num = int(input())
    end_num = int(input())
    
    result = solution(start_num, end_num)
    print(result)
```
**주요 개념 및 로직**
1. 끝 숫자부터 시작 숫자까지 내림차순 정렬이므로 for문 쓸 때 반대로 입력해주고 마지막에 reverse()

***

### Q55(가까운 1 찾기) / 리스트(배열)
```Python
def solution(arr, idx):
    answer = 0
    temp = []
    
    for i in range(idx, len(arr)):
        if (arr[i] == 1):
            temp.append(i)
            
    if temp:
        answer = min(temp)
    else:
        answer = -1
        
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    idx = int(input())
    
    result = solution
    print(result)
```
**주요 개념 및 로직**
1. 주어진 인덱스부터 끝 원소까지 순회
2. 1이 있으면 temp 리스트에 저장
3. temp 리스트에 1이 하나라도 있으면 그 중에 가장 작은 인덱스를 answer에 저장
4. 아니라면 answer에는 -1

***

### Q56(리스트 자르기) / 리스트(배열)
```Python
def solution(n, slicer, num_list):
    answer = []
    
    a = slicer[0]
    b = slicer[1]
    c = slicer[2]
        
    if (n == 1):
        return num_list[:b+1]
    elif (n == 2):
        return num_list[a:]
    elif (n == 3):
        return num_list[a:b+1]
    elif (n == 4):
        return num_list[a:b+1:2]

if __name__ == "__main__":
    n = int(input())
    slicer = list(map(int, input()))
    num_list = list(map(int, input()))
    
    result = solution(n, slicer, num_list)
    
    print(result)
```
**주요 개념 및 로직**
1. 리스트 슬라이싱에서 마지막 원소를 제대로 포함하려면 +1
2. 2개 간격으로 자르려면, 마지막에 2 ex) [start:end:step]

***

### Q57(첫 번째로 나오는 음수) / 리스트(배열)
```Python
def solution(num_list):
    answer = 0
    
    for val in num_list:
        if (val < 0) :
            answer = num_list.index(val)
            return answer
    
    answer = -1
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(reulst)
```
**주요 개념 및 로직**
1. val이 음수인 것이 나오면 index를 return
2. 아니라면 -1 저장 후 return

***

### Q58(배열 만들기 3) / 리스트(배열)
```Python
def solution(arr, intervals):
    answer = []
    
    for i in intervals:
        for j in range(i[0], i[1] + 1):
            answer.append(arr[j])
            
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    intervals = list(map(int, input()))
    
    result = solution(arr, intervals)
    print(result)
```
**주요 개념 및 로직**
1. 2차원 배열일 때, 먼저 첫 i에 [1, 3], [0, 4]와 같은 리스트들을 담는다
2. 그리고 j에 1부터 3까지, 0부터 4까지 담아주고 그것을 asnwer 리스트에 이어붙임.

***

### Q59(2의 영역) / 리스트(배열)
```Python
def solution(arr):
    answer = []
    
    if 2 not in arr:
        answer.append(-1)
        return answer
    
    else:
        first_2_index = arr.index(2)
        last_2_index = len(arr) - 1 - arr[::-1].index(2)
        #또 다른 방법: last_2 = max(i for i, val in enumerate(arr) if val == 2)
        
        answer = arr[first_2_index:last_2_index + 1]
        return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    
    result = solution(arr)
    print(result)
```
**주요 개념 및 로직**
1. 첫 2가 나오는 인덱스(index())
2. 끝 2가 나오는 인덱스 구하는 방법(리스트 뒤집어서 구하고 전체 길이에서 빼주기)
3. 정답 리스트에 두 인덱스 범위만큼 합치기

***

### Q60(배열 조각하기) / 리스트(배열)
```Python
def solution(arr, query):
    answer = []

    #for ch in query:
        #if (query.index(ch) %2 == 0):
            # 짝수 일때
            #arr = arr[:arr.index(ch) + 1]
        #else:
            # 홀수 일때
            #arr = arr[arr.index(ch):]
            
    for i in range(len(query)):
        if i % 2 == 0:
            # 짝수 일때
            arr = arr[:query[i] + 1]
        else:
            # 홀수 일때
            arr = arr[query[i]:]
            
    answer = arr
    
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    query = list(map(int, input()))
    
    result = solution(arr, query)
    print(result)
```
**주요 개념 및 로직**
1. Query의 길이만큼 순서대로 진행:
2. i가 짝수일때는 처음부터 query[i] + 1까지 arr에 저장
3. i가 홀수일때는 query[i]부터 끝까지 arr에 저장

***

### Q61(n번째 원소부터) / 리스트(배열)
```Python
def solution(num_list, n):
    answer = []
    
    for i in range(n-1, len(num_list)):
        answer.append(num_list[i])
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    n = int(input())
    
    result = solution(num_list, n)
    print(result)
```
**주요 개념 및 로직**
1. 인덱스를 추출하기 위해 n번째가 되려면 n-1로 인덱스를 적용해서 n-1부터 num_list의 길이(끝 인덱스) 동안 반복해서 num_list의 인덱스를 추출하여 answer 리스트에 넣는다.

***

### Q62(순서 바꾸기) / 리스트(배열)
```Python
def solution(num_list, n):
    answer = []
    answer = num_list[n:len(num_list)] + num_list[:n]
    
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    n = int(input())
    
    result = solution(num_list, n)
    print(result)
```
**주요 개념 및 로직**
1. n번째 이후의 원소들은 [n:len(num_list)]로 슬라이싱,
2. n은 인덱스가 아니라 n번째를 나타내는 것
3. n번째까지의 원소들은 [:n]으로 슬라이싱
4. :n에서 n 인덱스는 포함 안되기 때문에 n번째까지라는 뜻
5. n+1번째는 포함 안됨

***

### Q63(왼쪽 오른쪽) / 리스트(배열)
```Python
