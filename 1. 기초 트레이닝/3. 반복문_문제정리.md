# 기초 트레이닝 정리

[Python] 

모든 문제 번호는 '최신순' 정렬 되어 있는 문제들의 번호임.

## 반복문

### Q29(수열과 구간 쿼리 3) / 반복문
```Python
def solution(arr, queries):
    answer = []
    
    for query in queries:
        i = query[0]
        j = query[1]
        temp = arr[i]
        arr[i] = arr[j]
        arr[j] = temp
    
    answer = arr
    
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    queries = list(input())
    
    result = solution(arr, queries)
    print(result)
```
**주요 개념 및 로직**
1. quries의 원소들을 query라 할 때, query의 첫번째 원소를 i, 두번째 원소를 j에 할당하고, arr의 원소를 바꾸는 작업을 실시한다.
2. 작업은 temp에 arr[i]를 넣고, arr[i]를 arr[j]로 바꾼 후, arr[j]에 temp에 있던 원소를 넣는 식으로 진행한다.

***

### Q30(수열과 구간 쿼리 2) / 반복문
```Python
def solution(arr, queries):
    answer = []
    
    for query in queries:
        s = query[0]
        e = query[1]
        k = query[2]
        temp = []
        for i in range(s, e+1):   
            if (arr[i] > k):
                temp.append(arr[i])
        if temp:
            val = min(temp)
            answer.append(val)
        else:
            answer.append(-1)
            
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    queries = list(input())
    
    result = solution(arr, queries)
    print(result)
```
**주요 개념 및 로직**
1. queries의 원소들을 query라고 하고, s, e, k에 query의 원소들을 차례대로 담는다.
2. temp를 반복문을 돌 때마다 빈 리스트로 초기화 해준다.
3. s부터 e까지 arr의 원소가 k보다 큰 원소가 있다면 temp에 넣는다.
4. temp가 비어있지 않다면, 후보군들 중에 가장 작은 원소를 answer에 넣는다.
5. temp가 비어있다면, answer에는 -1을 넣는다.

***

### Q31(수열과 구간 쿼리 4) / 반복문
```Python
def solution(arr, queries):
    answer = []
    
    for query in queries:
        for i in range(query[0], query[1] + 1):
            if (i % query[2] == 0):
                arr[i] += 1
                
    answer = arr
    
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    queries = list(input())
    
    result = solution(arr, queries)
    print(result)
```
**주요 개념 및 로직**
1. queries는 2차원 배열이므로, for문으로 하나의 query씩 처리하고,
2. 각 query는 s, e, k 꼴이므로 i 변수의 범위를 query[0], query[1] + 1 (끝 인덱스 고려)로 주고 돌린다.
3. 그리고 만약 범위 내의 i 값을 query[2] = k 값으로 나눈 나머지가 0(k의 배수)이면 arr의 해당하는 값에 1을 더한다.

***
