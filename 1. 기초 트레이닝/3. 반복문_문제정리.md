# 기초 트레이닝 정리

[Python] 

모든 문제 번호는 '최신순' 정렬 되어 있는 문제들의 번호임.

## 반복문

### Q29(수열과 구간 쿼리 3) / 반복문
```Python
def solution(arr, queries):
    answer = []
    
    for query in queries:
        i = query[0]
        j = query[1]
        temp = arr[i]
        arr[i] = arr[j]
        arr[j] = temp
    
    answer = arr
    
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    queries = list(input())
    
    result = solution(arr, queries)
    print(result)
```
**주요 개념 및 로직**
1. quries의 원소들을 query라 할 때, query의 첫번째 원소를 i, 두번째 원소를 j에 할당하고, arr의 원소를 바꾸는 작업을 실시한다.
2. 작업은 temp에 arr[i]를 넣고, arr[i]를 arr[j]로 바꾼 후, arr[j]에 temp에 있던 원소를 넣는 식으로 진행한다.

***

### Q30(수열과 구간 쿼리 2) / 반복문
```Python
def solution(arr, queries):
    answer = []
    
    for query in queries:
        s = query[0]
        e = query[1]
        k = query[2]
        temp = []
        for i in range(s, e+1):   
            if (arr[i] > k):
                temp.append(arr[i])
        if temp:
            val = min(temp)
            answer.append(val)
        else:
            answer.append(-1)
            
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    queries = list(input())
    
    result = solution(arr, queries)
    print(result)
```
**주요 개념 및 로직**
1. queries의 원소들을 query라고 하고, s, e, k에 query의 원소들을 차례대로 담는다.
2. temp를 반복문을 돌 때마다 빈 리스트로 초기화 해준다.
3. s부터 e까지 arr의 원소가 k보다 큰 원소가 있다면 temp에 넣는다.
4. temp가 비어있지 않다면, 후보군들 중에 가장 작은 원소를 answer에 넣는다.
5. temp가 비어있다면, answer에는 -1을 넣는다.

***

### Q31(수열과 구간 쿼리 4) / 반복문
```Python
def solution(arr, queries):
    answer = []
    
    for query in queries:
        for i in range(query[0], query[1] + 1):
            if (i % query[2] == 0):
                arr[i] += 1
                
    answer = arr
    
    return answer

if __name__ == "__main__":
    arr = list(map(int, input()))
    queries = list(input())
    
    result = solution(arr, queries)
    print(result)
```
**주요 개념 및 로직**
1. queries는 2차원 배열이므로, for문으로 하나의 query씩 처리하고,
2. 각 query는 s, e, k 꼴이므로 i 변수의 범위를 query[0], query[1] + 1 (끝 인덱스 고려)로 주고 돌린다.
3. 그리고 만약 범위 내의 i 값을 query[2] = k 값으로 나눈 나머지가 0(k의 배수)이면 arr의 해당하는 값에 1을 더한다.

***

### Q32(배열 만들기 2) / 반복문
```Python
def solution(l, r):
    answer = []
    for i in range(l, r+1):
        if not set(str(i)) - set(['0', '5']):
            answer.append(i)
    return answer if answer else [-1]

if __name__ == "__main__":
    l, r = int(input())
    
    result = solution(l, r)
    print(result)
```
**주요 개념 및 로직**
1. l부터 r까지 반복문에서, 현재 숫자(i)를 집합으로 바꾸고, 차집합 연산을 실행한다.
2. 숫자 집합이 0, 5로만 구성되어 있으면 차집합 연산에 의해 빈 집합이 되고, 그러면 조건을 만족하여 answer에 넣게 된다.
3. 순차적으로 진행한 후, answer 리스트를 반환하는데, 빈 리스트라면 [-1]을 반환한다.

***

### Q33(카운트 업) / 반복문
```Python
def solution(start_num, end_num):
    answer = []
    for i in range(start_num, end_num+1):
        answer.append(i)    
    return answer


if __name__ == "__main__":
    start_num = int(input())
    end_num = int(input())

    answer = solution(start_num, end_num)
    print(answer)
```
**주요 개념 및 로직**
1. start_num부터 end_num + 1 까지 i라는 숫자에 할당해서 answer에 붙인다.

***

### Q34(콜라츠 수열 만들기) / 반복문
```Python
def solution(num):
    answer = []
    answer.append(num)

    while(num != 1):
        if num % 2 == 0:
            num = num // 2
        else:
            num = (num * 3 + 1)    
        answer.append(num)
    return answer

if __name__ == "__main__":
    num = int(input())
    result = solution(num)

    print(result)
```
**주요 개념 및 로직**
1. 우선 num을 answer에 넣어주고, while문을 진행한다.
2. while문 조건은 num이 1이 될 때까지 해당 작업을 반복한다:
3. num이 짝수이면 2로 나누고, 홀수이면 3을 곱한 것에 1을 더한다.
4. 해당 작업을 반복하면 언젠가는 1이 되어 while문을 탈출하게 된다.

***

### Q35(배열 만들기 4) / 반복문
```Python
def solution(arr):
    stk = []
    i = 0
    while i < len(arr):
        if not stk:
            stk.append(arr[i])
            i += 1
        elif stk[-1] < arr[i]:
            stk.append(arr[i])
            i += 1
        else:
            stk.pop()      
            
    return stk

if __name__ == "__main__":
    arr = list(map(int, input().split()))
    result = solution(arr)

    print(result)
```
**주요 개념 및 로직**
1. i에 0을 할당하고, i가 arr의 길이보다 작은 동안 반복한다:
2. stk 리스트가 비어있으면, arr의 해당 원소를 stk에 붙이고 i에 1을 더한다.
3. 만약 stk 리스트에 원소가 있고, stk의 마지막 원소가 arr의 현재 원소보다 작으면 arr의 해당 원소를 stk에 붙이고 i에 1을 더한다.
4. 만약 stk 리스트에 원소가 있고, stk의 마지막 원소가 arr의 현재 원소보다 크거나 같으면, stk의 제일 최근의 원소를 제거한다.

***
